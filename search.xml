<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>热题100-BFS</title>
      <link href="/archives/d2a60114.html"/>
      <url>/archives/d2a60114.html</url>
      
        <content type="html"><![CDATA[<h3 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a>课程表</h3><p>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] &#x3D; [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。</p><p>例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。<br>请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。<br>链接：<a href="https://leetcode.cn/problems/course-schedule">https://leetcode.cn/problems/course-schedule</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt;[] sets = <span class="keyword">new</span> <span class="title class_">HashSet</span>[n];</span><br><span class="line">        <span class="type">int</span>[] inDegree = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sets[i] = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] p : prerequisites) &#123;</span><br><span class="line">            sets[p[<span class="number">1</span>]].add(p[<span class="number">0</span>]);</span><br><span class="line">            inDegree[p[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                que.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s : sets[t]) &#123;</span><br><span class="line">                inDegree[s]--;</span><br><span class="line">                <span class="keyword">if</span> (inDegree[s] == <span class="number">0</span>) &#123;</span><br><span class="line">                    que.add(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 热题100 </category>
          
          <category> BFS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热题100-贪心</title>
      <link href="/archives/b18ffce.html"/>
      <url>/archives/b18ffce.html</url>
      
        <content type="html"><![CDATA[<h3 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h3><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] &#x3D; [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p><p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] &#x3D; [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。<br>链接：<a href="https://leetcode.cn/problems/queue-reconstruction-by-height">https://leetcode.cn/problems/queue-reconstruction-by-height</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> people.length;</span><br><span class="line">        Arrays.sort(people, (a,b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] != b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span>  <span class="keyword">return</span> b[<span class="number">1</span>] - a[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> people[i][<span class="number">1</span>] + <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (res[j] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    target--;</span><br><span class="line">                    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">                        res[j] = people[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 热题100 </category>
          
          <category> 贪心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/archives/c24675b4.html"/>
      <url>/archives/c24675b4.html</url>
      
        <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h2><table><thead><tr><th align="center">分裂</th><th align="center">全称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">DDL</td><td align="center">Data Definition Language</td><td align="center">数据定义语言，用来定义数据库对象(数据库，表， 字段)</td></tr><tr><td align="center">DML</td><td align="center">Data Manipulation Language</td><td align="center">数据操作语言，用来对数据库表中的数据进行增删改</td></tr><tr><td align="center">DQL</td><td align="center">Data Query Language</td><td align="center">数据查询语言，用来查询数据库中表的记录</td></tr><tr><td align="center">DCL</td><td align="center">Data Control Language</td><td align="center">数据控制语言，用来创建数据库用户、控制数据库的 访问权限</td></tr></tbody></table><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show databases; # 查询所有数据库</span><br><span class="line">create database [ if not exists ] 数据库名 [ default charset 字符集 ] [ collate 排序</span><br><span class="line">规则 ]; # 创建数据库</span><br><span class="line">drop database [ if exists ] 数据库名 ; # 删除数据库</span><br><span class="line">use 数据库名; # 切换数据库</span><br><span class="line">select database(); # 查询当前使用的数据库</span><br></pre></td></tr></table></figure><h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><h4 id="查询创建"><a href="#查询创建" class="headerlink" title="查询创建"></a>查询创建</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show tables;                   # 查询当前数据库所有表</span><br><span class="line">desc 表名;                      # 查看指定表结构</span><br><span class="line">show create table 表名;         # 查询指定表的建表语句</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">字段1 字段1类型 [ COMMENT 字段1注释 ],</span><br><span class="line">字段2 字段2类型 [COMMENT 字段2注释 ],</span><br><span class="line">字段3 字段3类型 [COMMENT 字段3注释 ],</span><br><span class="line">......</span><br><span class="line">字段n 字段n类型 [COMMENT 字段n注释 ]</span><br><span class="line">) [ COMMENT 表注释 ] ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>数值类型：</p><table><thead><tr><th align="center">类型</th><th align="center">大小</th><th align="center">有符号范围（signed）</th><th align="center">无符号范围（unsigned）</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">TINYINT</td><td align="center">1byte</td><td align="center">(-128，127)</td><td align="center">(0，255)</td><td align="center">小整数值</td></tr><tr><td align="center">SMALLINT</td><td align="center">2bytes</td><td align="center">(-32768，32767)</td><td align="center">(0，65535)</td><td align="center">大整数值</td></tr><tr><td align="center">MEDIUMINT</td><td align="center">3bytes</td><td align="center">(-8388608，8388607)</td><td align="center">(0，16777215)</td><td align="center">大整数值</td></tr><tr><td align="center">INT</td><td align="center">4bytes</td><td align="center">(-2147483648， 2147483647)</td><td align="center">(0，4294967295)</td><td align="center">大整数值</td></tr><tr><td align="center">BIGINT</td><td align="center">8bytes</td><td align="center">(-2^63，2^63-1)</td><td align="center">(0，2^64-1)</td><td align="center">极大整数值</td></tr><tr><td align="center">FLOAT</td><td align="center">4bytes</td><td align="center">(-3.402823466 E+38， 3.402823466351 E+38)</td><td align="center">0 和 (1.175494351 E-38，3.402823466 E+38)</td><td align="center">单精度浮点数值</td></tr><tr><td align="center">DOUBLE</td><td align="center">8bytes</td><td align="center">(-1.7976931348623157 E+308， 1.7976931348623157 E+308)</td><td align="center">0 和 (2.2250738585072014 E-308， 1.7976931348623157 E+308)</td><td align="center">双精度浮点数 值</td></tr><tr><td align="center">DECIMAL</td><td align="center"></td><td align="center">依赖于M(精度)和D(标度) 的值</td><td align="center">依赖于M(精度)和D(标度)的 值</td><td align="center">小数 值(精 确定 点数)</td></tr></tbody></table><p>字符串类型：</p><table><thead><tr><th align="center">类型</th><th align="center">大小</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">CHAR</td><td align="center">0-255 bytes</td><td align="center">定长字符串(需要指定长度)</td></tr><tr><td align="center">VARCHAR</td><td align="center">0-65535 bytes</td><td align="center">变长字符串(需要指定长度)</td></tr><tr><td align="center">TINYBLOB</td><td align="center">0-255 bytes</td><td align="center">不超过255个字符的二进制数据</td></tr><tr><td align="center">TINYTEXT</td><td align="center">0-255 bytes</td><td align="center">短文本字符串</td></tr><tr><td align="center">BLOB</td><td align="center">0-65535 bytes</td><td align="center">二进制形式的长文本数据</td></tr><tr><td align="center">TEXT</td><td align="center">0-65535 bytes</td><td align="center">长文本数据</td></tr><tr><td align="center">MEDIUMBLOB</td><td align="center">0-16777215 bytes</td><td align="center">二进制形式的中等长度文本数据</td></tr><tr><td align="center">MEDIUMTEXT</td><td align="center">0-16777215 bytes</td><td align="center">中等长度文本数据</td></tr><tr><td align="center">LONGBLOB</td><td align="center">0-4 294967295 bytes</td><td align="center">二进制形式的极大文本数据</td></tr><tr><td align="center">LONGTEXT</td><td align="center">0-4 294967295 bytes</td><td align="center">极大文本数据</td></tr></tbody></table><p>日期时间类型：</p><table><thead><tr><th align="center">类型</th><th align="center">大小</th><th align="center">范围</th><th align="center">格式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">DATE</td><td align="center">3</td><td align="center">1000-01-01 至 9999-12-31</td><td align="center">YYYY-MM-DD</td><td align="center">日期值</td></tr><tr><td align="center">TIME</td><td align="center">3</td><td align="center">-838:59:59 至 838:59:59</td><td align="center">HH:MM:SS</td><td align="center">时间值或持续时间</td></tr><tr><td align="center">YEAR</td><td align="center">1</td><td align="center">1901 至 2155</td><td align="center">YYYY</td><td align="center">年份值</td></tr><tr><td align="center">DATETIME</td><td align="center">8</td><td align="center">1000-01-01 00:00:00 至 9999-12-31 23:59:59</td><td align="center">YYYY-MM-DD HH:MM:SS</td><td align="center">混合日期和时间值</td></tr><tr><td align="center">TIMESTAMP</td><td align="center">4</td><td align="center">1970-01-01 00:00:01 至 2038-01-19 03:14:07</td><td align="center">YYYY-MM-DD HH:MM:SS</td><td align="center">混合日期和时 间值，时间戳</td></tr></tbody></table><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD 字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];   # 添加字段</span><br><span class="line">ALTER TABLE 表名 MODIFY 字段名 新数据类型 (长度);   # 修改字段的数据类型</span><br><span class="line">ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];  # 修改字段的名称</span><br><span class="line">ALTER TABLE 表名 DROP 字段名;  # 删除字段</span><br><span class="line">ALTER TABLE 表名 RENAME TO 新表名;  # 修改表名称</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE [ IF EXISTS ] 表名; # 删除表</span><br><span class="line">TRUNCATE TABLE 表名；          # 删除指定表, 并重新创建表</span><br></pre></td></tr></table></figure><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...); # 给指定字段添加数据</span><br><span class="line">INSERT INTO 表名 VALUES (值1, 值2, ...); #  给全部字段添加数据</span><br><span class="line">INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值</span><br><span class="line">1, 值2, ...) ;  # 给指定字段添加多条数据</span><br><span class="line">INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ; #  给全部字段添加多条数据</span><br></pre></td></tr></table></figure><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE 表名 SET 字段名1 = 值1 , 字段名2 = 值2 , .... [ WHERE 条件 ];  # 修改字段的值</span><br></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM 表名 [ WHERE 条件 ] ;  # 删除某几行数据</span><br></pre></td></tr></table></figure><h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">字段列表</span><br><span class="line">FROM</span><br><span class="line">表名列表</span><br><span class="line">WHERE</span><br><span class="line">条件列表</span><br><span class="line">GROUP BY</span><br><span class="line">分组字段列表</span><br><span class="line">HAVING</span><br><span class="line">分组后条件列表</span><br><span class="line">ORDER BY</span><br><span class="line">排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">分页参数</span><br></pre></td></tr></table></figure><h3 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段1 [ AS 别名1 ] , 字段2 [ AS 别名2 ] ... FROM 表名;</span><br><span class="line">SELECT * FROM 表名 ;</span><br><span class="line">SELECT DISTINCT 字段列表 FROM 表名;  # 去除重复的记录</span><br></pre></td></tr></table></figure><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 WHERE 条件列表;</span><br></pre></td></tr></table></figure><p>常用比较运算符：</p><table><thead><tr><th align="center">比较运算符</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&gt;&#x3D;</td><td align="center">大于等于</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&lt;&#x3D;</td><td align="center">小于等于</td></tr><tr><td align="center">&#x3D;</td><td align="center">等于</td></tr><tr><td align="center">&lt;&gt; 或 !&#x3D;</td><td align="center">不等于</td></tr><tr><td align="center">BETWEEN … ADN …</td><td align="center">在某个范围之内(含最小、最大值)</td></tr><tr><td align="center">IN(…)</td><td align="center">在in之后的列表中的值，多选一</td></tr><tr><td align="center">LIKE 占位符</td><td align="center">模糊匹配(_匹配单个字符, %匹配任意个字符)</td></tr><tr><td align="center">IS NULL</td><td align="center">是NULL</td></tr></tbody></table><p>常用逻辑运算符：</p><table><thead><tr><th align="center">逻辑运算符</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">AND 或 &amp;&amp;</td><td align="center">并且 (多个条件同时成立)</td></tr><tr><td align="center">OR 或 ||</td><td align="center">或者 (多个条件任意一个成立)</td></tr><tr><td align="center">NOT 或 !</td><td align="center">非 , 不是</td></tr></tbody></table><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>聚合函数将一列数据作为一个整体，进行纵向计算。</p><blockquote><p>null值不参与聚合函数运算</p></blockquote><p>常见聚合函数：</p><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">count</td><td align="center">统计数量</td></tr><tr><td align="center">max</td><td align="center">最大值</td></tr><tr><td align="center">min</td><td align="center">最小值</td></tr><tr><td align="center">avg</td><td align="center">平均值</td></tr><tr><td align="center">sum</td><td align="center">求和</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 聚合函数(字段列表) FROM 表名 ;</span><br></pre></td></tr></table></figure><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组</span><br><span class="line">后过滤条件 ];</span><br></pre></td></tr></table></figure><p>where和having的区别：</p><ul><li><p>where在分组之前进行过滤，having是分组之后进行过滤。</p></li><li><p>where不能对聚合函数进行判断，而having可以</p></li></ul><blockquote><p>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</p><p>执行顺序: where &gt; 聚合函数 &gt; having </p><p>支持多字段分组, 具体语法为 : group by columnA,columnB</p></blockquote><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1 , 字段2 排序方式2 ;</span><br></pre></td></tr></table></figure><p>排序方式：</p><p>ASC：升序排序。</p><p>DESC：降序排序。</p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;</span><br></pre></td></tr></table></figure><p>其实索引从0开始，起始索引 &#x3D; （查询页码 - 1） * 每页显示记录数。</p><h3 id="执行逆序"><a href="#执行逆序" class="headerlink" title="执行逆序"></a>执行逆序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from  表名列表</span><br><span class="line">where 条件列表</span><br><span class="line">group by 分组字段列表</span><br><span class="line">having 分组后条件列表</span><br><span class="line">select 字段列表</span><br><span class="line">order by 排序字段列表</span><br><span class="line">limit 分段参数</span><br></pre></td></tr></table></figure><h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2><p>DCL英文全称是Data Control Language(数据控制语言)，用来管理数据库用户、控制数据库的访 问权限。</p><h3 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">select * from mysql.user; # 查询用户</span><br><span class="line">CREATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;;  # 创建用户</span><br><span class="line">ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;; # 修改用户密码</span><br><span class="line">DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27;; # 删除用户</span><br></pre></td></tr></table></figure><h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><p>常用权限：</p><table><thead><tr><th align="center">权限</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ALL, ALL PRIVILEGES</td><td align="center">所有权限</td></tr><tr><td align="center">SELECT</td><td align="center">查询数据</td></tr><tr><td align="center">INSERT</td><td align="center">插入数据</td></tr><tr><td align="center">UPDATE</td><td align="center">修改数据</td></tr><tr><td align="center">DELETE</td><td align="center">删除数据</td></tr><tr><td align="center">ALTER</td><td align="center">修改表</td></tr><tr><td align="center">DROP</td><td align="center">删除数据库&#x2F;表&#x2F;视图</td></tr><tr><td align="center">CREATE</td><td align="center">创建数据库&#x2F;表</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机名&#x27; ; # 查询权限 </span><br><span class="line">GRANT 权限列表 ON 数据库名.表名 TO &#x27;用户名&#x27;@&#x27;主机名&#x27;; #  授予权限</span><br><span class="line">REVOKE 权限列表 ON 数据库名.表名 FROM &#x27;用户名&#x27;@&#x27;主机名&#x27;; # 撤销权限</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">CONCAT(S1,S2,…Sn)</td><td align="center">字符串拼接，将S1，S2，… Sn拼接成一个字符串</td></tr><tr><td align="center">LOWER(str)</td><td align="center">将字符串str全部转为小写</td></tr><tr><td align="center">UPPER(str)</td><td align="center">将字符串str全部转为大写</td></tr><tr><td align="center">LPAD(str,n,pad)</td><td align="center">左填充，用字符串pad对str的左边进行填充，达到n个字符 串长度</td></tr><tr><td align="center">RPAD(str,n,pad)</td><td align="center">右填充，用字符串pad对str的右边进行填充，达到n个字符 串长度</td></tr><tr><td align="center">TRIM(str)</td><td align="center">去掉字符串头部和尾部的空格</td></tr><tr><td align="center">SUBSTRING(str,start,len)</td><td align="center">返回从字符串str从start位置起的len个长度的字符串</td></tr></tbody></table><h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">CEIL(x)</td><td align="center">向上取整</td></tr><tr><td align="center">FLOOR(x)</td><td align="center">向下取整</td></tr><tr><td align="center">MOD(x,y)</td><td align="center">返回x&#x2F;y的模</td></tr><tr><td align="center">RAND()</td><td align="center">返回0~1内的随机数</td></tr><tr><td align="center">ROUND(x,y)</td><td align="center">求参数x的四舍五入的值，保留y位小数</td></tr></tbody></table><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">CURDATE()</td><td align="center">返回当前日期</td></tr><tr><td align="center">CURTIME()</td><td align="center">返回当前时间</td></tr><tr><td align="center">NOW()</td><td align="center">返回当前日期和时间</td></tr><tr><td align="center">YEAR(date) &#x2F;MONTH(data) &#x2F; DAY(date)</td><td align="center">获取指定date的年份 &#x2F; 月份 &#x2F;日期</td></tr><tr><td align="center">DATE_ADD(date, INTERVAL expr type)</td><td align="center">返回一个日期&#x2F;时间值加上一个时间间隔expr后的 时间</td></tr><tr><td align="center">DATEDIFF(date1,date2)</td><td align="center">返回起始时间date1 和 结束时间date2之间的天 数</td></tr></tbody></table><h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h3><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">IF(value , t , f)</td><td align="center">如果value为true，则返回t，否则返回 f</td></tr><tr><td align="center">IFNULL(value1 , value2)</td><td align="center">如果value1不为空，返回value1，否则 返回value2</td></tr><tr><td align="center">NOW()</td><td align="center">返回当前日期和时间</td></tr><tr><td align="center">CASE WHEN [ val1 ] THEN [res1] … ELSE [ default ] END</td><td align="center">如果val1为true，返回res1，… 否 则返回default默认值</td></tr><tr><td align="center">CASE [ expr ] WHEN [ val1 ] THEN [res1] … ELSE [ default ] END</td><td align="center">如果expr的值等于val1，返回 res1，… 否则返回default默认值</td></tr></tbody></table><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="普通约束"><a href="#普通约束" class="headerlink" title="普通约束"></a>普通约束</h3><table><thead><tr><th align="center">约束</th><th align="center">描述</th><th align="center">关键字</th></tr></thead><tbody><tr><td align="center">非空约束</td><td align="center">限制该字段的数据不能为null</td><td align="center">NOT NULL</td></tr><tr><td align="center">唯一约束</td><td align="center">保证该字段的所有数据都是唯一、不重复的</td><td align="center">UNIQUE</td></tr><tr><td align="center">主键约束</td><td align="center">主键是一行数据的唯一标识，要求非空且唯一</td><td align="center">PRIMARY KEY</td></tr><tr><td align="center">默认约束</td><td align="center">保存数据时，如果未指定该字段的值，则采用默认值</td><td align="center">DEFAULT</td></tr><tr><td align="center">检查约束(8.0.16版本 之后）</td><td align="center">保证字段值满足某一个条件</td><td align="center">CHECK</td></tr><tr><td align="center">外键约束</td><td align="center">用来让两张表的数据之间建立连接，保证数据的一致 性和完整性</td><td align="center">FOREIGN KEY</td></tr></tbody></table><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>添加外键：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">...</span><br><span class="line">[CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名)</span><br><span class="line">REFERENCES 主表 (主表列名) ;</span><br></pre></td></tr></table></figure><p>删除外键：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</span><br></pre></td></tr></table></figure><p>删除&#x2F;更新行为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES</span><br><span class="line">主表名 (主表字段名) ON UPDATE CASCADE ON DELETE CASCADE;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">行为</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">NO ACTION</td><td align="center">当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不 允许删除&#x2F;更新。 (与 RESTRICT 一致) 默认行为</td></tr><tr><td align="center">RESTRICT</td><td align="center">当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不 允许删除&#x2F;更新。 (与 NO ACTION 一致) 默认行为</td></tr><tr><td align="center">CASCADE</td><td align="center">当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有，则 也删除&#x2F;更新外键在子表中的记录。</td></tr><tr><td align="center">SET NULL</td><td align="center">当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表 中该外键值为null（这就要求该外键允许取null）。</td></tr><tr><td align="center">SET DEFAULT</td><td align="center">父表有变更时，子表将外键列设置成一个默认的值 (Innodb不支持)</td></tr></tbody></table><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>内连接查询的是两张表的交集部分</p><p>隐式内连接：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 , 表2 WHERE 条件 ... ;</span><br></pre></td></tr></table></figure><p>显示内连接：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ... ;</span><br></pre></td></tr></table></figure><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>左外连接查询的是左表的所有数据。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ... ;</span><br></pre></td></tr></table></figure><p>右外连接查询的是右表的所有数据。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ... ;</span><br></pre></td></tr></table></figure><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>自连接就是自己连接自己多次。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ... ;</span><br></pre></td></tr></table></figure><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>联合查询就是将多次查询的结果合并起来，形成一个新的查询结果集。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表A ...</span><br><span class="line">UNION [ ALL ]</span><br><span class="line">SELECT 字段列表 FROM 表B ....;</span><br></pre></td></tr></table></figure><blockquote><p>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。</p><p>union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。</p></blockquote><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><h4 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h4><p>子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。</p><p>常用的操作符：&#x3D; &lt;&gt; &gt; &gt;&#x3D; &lt; &lt;&#x3D; </p><h4 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h4><p>子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。 常用的操作符：IN 、NOT IN 、 ANY 、SOME 、 ALL</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">IN</td><td align="center">在指定的集合范围之内，多选一</td></tr><tr><td align="center">NOT IN</td><td align="center">不在指定的集合范围之内</td></tr><tr><td align="center">ANY</td><td align="center">子查询返回列表中，有任意一个满足即可</td></tr><tr><td align="center">SOME</td><td align="center">与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td align="center">ALL</td><td align="center">子查询返回列表的所有值都必须满足</td></tr></tbody></table><h4 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h4><p>子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。 常用的操作符：&#x3D; 、&lt;&gt; 、IN 、NOT IN</p><p>例子：查询与 “张无忌” 的薪资及直属领导相同的员工信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where (salary,managerid) = (select salary, managerid from emp</span><br><span class="line">where name = &#x27;张无忌&#x27;);</span><br></pre></td></tr></table></figure><h4 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h4><p>子查询返回的结果是多行多列，这种子查询称为表子查询。 常用的操作符：IN</p><p>例子： 查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where (job,salary) in ( select job, salary from emp where name =</span><br><span class="line">&#x27;鹿杖客&#x27; or name = &#x27;宋远桥&#x27; );</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><h3 id="控制事务"><a href="#控制事务" class="headerlink" title="控制事务"></a>控制事务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION 或 BEGIN ; # 开启事务</span><br><span class="line">COMMIT;  # 提交事务</span><br><span class="line">ROLLBACK; # 回滚事务 </span><br></pre></td></tr></table></figure><h3 id="事务四大特性（ACID）"><a href="#事务四大特性（ACID）" class="headerlink" title="事务四大特性（ACID）"></a>事务四大特性（ACID）</h3><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。 </li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 环境下运行。 </li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><h3 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h3><p>脏读：一个事务读取到了另外一个事务还未提交的数据。</p><p>不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同。</p><p>幻读：一个事务查询数据时，没有对应的数据行，但是插入数据时，又说存在不让插，出现“幻觉”。</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。</p><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">读未提交(Read uncommitted)</td><td align="center">无法解决</td><td align="center">无法解决</td><td align="center">无法解决</td></tr><tr><td align="center">读已提交(Read committed)</td><td align="center">解决</td><td align="center">无法解决</td><td align="center">无法解决</td></tr><tr><td align="center">可重复读(Repeatable Read) (默认)</td><td align="center">解决</td><td align="center">解决</td><td align="center">无法解决</td></tr><tr><td align="center">串行化(Serializable)</td><td align="center">解决</td><td align="center">解决</td><td align="center">解决</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @@TRANSACTION_ISOLATION;   # 查看事务隔离级别</span><br><span class="line">SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123; READ UNCOMMITTED |</span><br><span class="line">READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;   # 设置事务隔离级别</span><br></pre></td></tr></table></figure><h1 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h1><img src="/archives/c24675b4/mysql-structure.png" class title="MySQL体系结构"><ul><li><p>连接层：</p><p>最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端&#x2F;服务端工具实现的类似于 TCP&#x2F;IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程 池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务 器也会为安全接入的每个客户端验证它所具有的操作权限。</p></li><li><p>服务层</p><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部 分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解 析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大， 这样在解决大量读操作的环境中能够很好的提升系统的性能。</p></li><li><p>引擎层</p><p>存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通 信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库 中的索引是在存储引擎层实现的。</p></li><li><p>存储层</p><p>数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询 日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。 和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要 体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。 这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p></li></ul><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>建表时指定存储引擎</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">字段<span class="number">1</span> 字段<span class="number">1</span>类型 [ COMMENT 字段<span class="number">1</span>注释 ] ,</span><br><span class="line">......</span><br><span class="line">字段n 字段n类型 [COMMENT 字段n注释 ]</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB [ COMMENT 表注释 ] ;</span><br></pre></td></tr></table></figure><p>查询当前数据库支持的存储引擎</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> engines;</span><br></pre></td></tr></table></figure><p>查询建表语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> account;</span><br></pre></td></tr></table></figure><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的 MySQL 存储引擎。</p><p>特点：</p><ul><li><p>DML操作遵循ACID模型，<strong>支持事务</strong>；</p></li><li><p><strong>支持行级锁</strong>，提高并发访问性能； </p></li><li><p><strong>支持外键</strong>FOREIGN KEY约束，保证数据的完整性和正确性；</p></li></ul><p>文件：</p><p>xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm-早期的 、sdi-新版的）、数据和索引。</p><p>逻辑存储结构：</p><ul><li>表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以 包含多个Segment段。</li><li>段 :表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管 理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。</li><li>区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为 16K， 即一个区中一共有64个连续的页。</li><li>页 : 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默 认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</li><li>行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时 所指定的字段以外，还包含两个隐藏字段。</li></ul><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM是MySQL早期的默认存储引擎。</p><p>特点：</p><p>不支持事务，不支持外键 支持表锁，不支持行锁 访问速度快。</p><p>文件：</p><p>xxx.sdi：存储表结构信息 </p><p>xxx.MYD: 存储数据</p><p> xxx.MYI: 存储索引</p><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为 临时表或缓存使用。</p><p>特点：</p><p>内存存放 hash索引（默认）</p><p>文件：</p><p>xxx.sdi：存储表结构信息</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足 特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构 上实现高级查找算法，这种数据结构就是索引。</p><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：</p><table><thead><tr><th align="center">索引结构</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">B+Tree索引</td><td align="center">最常见的索引类型，大部分引擎都支持 B+ 树索引</td></tr><tr><td align="center">Hash索引</td><td align="center">底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询</td></tr><tr><td align="center">R-tree(空间索 引）</td><td align="center">空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类 型，通常使用较少</td></tr><tr><td align="center">Full-text(全文 索引)</td><td align="center">是一种通过建立倒排索引,快速匹配文档的方式。类似于 Lucene,Solr,ES</td></tr></tbody></table><p>不同存储引擎对索引结构的支持：</p><table><thead><tr><th align="center">索引</th><th align="center">InnoDB</th><th align="center">MyISAM</th><th align="center">Memory</th></tr></thead><tbody><tr><td align="center">B+tree索引</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">Hash 索引</td><td align="center">不支持</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">R-tree 索引</td><td align="center">不支持</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center">Full-text</td><td align="center">5.6版本之后支持</td><td align="center">支持</td><td align="center">不支持</td></tr></tbody></table><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p>B-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。 以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5 个指针。</p><p><img src="/archives/Users\王嘉毓\AppData\Roaming\Typora\typora-user-images\image-20220819164513518.png" alt="image-20220819164513518"></p><h4 id="B-tree"><a href="#B-tree" class="headerlink" title="B+tree"></a>B+tree</h4><p>B+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例。</p><p><img src="/archives/Users\王嘉毓\AppData\Roaming\Typora\typora-user-images\image-20220819164545134.png" alt="image-20220819164545134"></p><p>MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点 的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。</p><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在 hash表中。</p><p>Hash索引只能用于对等比较(&#x3D;，in)，不支持范围查询（between，&gt;，&lt; ，…） </p><p>Hash索引无法利用索引完成排序操作 </p><p>Hash索引查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索 引</p><p>在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是 InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。</p><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p>在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。</p><table><thead><tr><th align="center">分类</th><th align="center">含义</th><th align="center">特点</th><th align="center">关键字</th></tr></thead><tbody><tr><td align="center">主键索引</td><td align="center">针对于表中主键创建的索引</td><td align="center">默认自动创建, 只能 有一个</td><td align="center">PRIMARY</td></tr><tr><td align="center">唯一 索引</td><td align="center">避免同一个表中某数据列中的值重复时</td><td align="center">可以有多个</td><td align="center">UNIQUE</td></tr><tr><td align="center">常规索引</td><td align="center">快速定位特定数据</td><td align="center">可以有多个</td><td align="center"></td></tr><tr><td align="center">全文 索引</td><td align="center">全文索引查找的是文本中的关键词，而不是比 较索引中的值</td><td align="center">可以有多个</td><td align="center">FULLTEXT</td></tr></tbody></table><p>在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th align="center">分类</th><th align="center">含义</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">聚集索引(Clustered Index）</td><td align="center">将数据存储与索引放到了一块，索引结构的叶子 节点保存了行数据</td><td align="center">必须有,而且只 有一个</td></tr><tr><td align="center">二级索引(Secondary Index)</td><td align="center">将数据与索引分开存储，索引结构的叶子节点关 联的是对应的主键</td><td align="center">可以存在多个</td></tr></tbody></table><p>聚集索引选取规则: </p><ul><li>如果存在主键，主键索引就是聚集索引。 </li><li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。 </li><li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索 引。</li></ul><p>回表查询：</p><ul><li>先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取 数据的方式，就称之为回表查询。</li></ul><h3 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h3><p>创建索引</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT ] INDEX index_name <span class="keyword">ON</span> table_name (</span><br><span class="line">index_col_name,... ) ;</span><br></pre></td></tr></table></figure><p>查看索引 </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name ;</span><br></pre></td></tr></table></figure><p>删除索引</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name ;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热题100-二维数组</title>
      <link href="/archives/9e3bc9c0.html"/>
      <url>/archives/9e3bc9c0.html</url>
      
        <content type="html"><![CDATA[<h3 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h3><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。<br>链接：<a href="https://leetcode.cn/problems/rotate-image">https://leetcode.cn/problems/rotate-image</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rotateEdge</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;  d - b; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> matrix[a][b+i];</span><br><span class="line">            matrix[a][b+i] = matrix[c-i][b];</span><br><span class="line">            matrix[c-i][b] = matrix[c][d-i];</span><br><span class="line">            matrix[c][d-i] = matrix[a+i][d];</span><br><span class="line">            matrix[a+i][d] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (a &lt; c) &#123;</span><br><span class="line">            rotateEdge(matrix, a++, b++, c--, d--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 热题100 </category>
          
          <category> 二维数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/archives/53d0684b.html"/>
      <url>/archives/53d0684b.html</url>
      
        <content type="html"><![CDATA[<h2 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h2><p>Linux目录结构采用层级式树状目录结构，此结构中最上层的是根目录<code>/</code>。</p><h3 id="具体目录"><a href="#具体目录" class="headerlink" title="具体目录"></a>具体目录</h3><p><code>/bin</code>：存放经常使用的命令</p><p><code>/sbin</code>：存放系统管理员使用的系统管理程序</p><p><code>/home</code>：存放普通用户的主目录的目录</p><p><code>/root</code>：超级权限者的用户主目录</p><p><code>/lib</code>：动态链接共享库</p><p><code>/lost+found</code>：系统非法关机后，存放文件</p><p><code>/etc</code>：存放配置文件和子目录</p><p><code>/usr</code>：用户的应用程序和文件存放在此目录下</p><p><code>/boot</code>：存放启动Linux时使用的核心文件，包括连接文件和镜像文件</p><p><code>/tmp</code>：存放临时文件</p><p><code>dev</code>：把所有的硬件用文件的形式存储</p><p><code>/media</code>：U盘、光驱等识别后，会把识别的设备挂载到此目录下。</p><p><code>/mnt</code>：可以将外部的存储挂载到<code>/mt</code></p><p><code>/opt</code>：给主机额外安装软件所存放的目录</p><p><code>/usr/local</code>：给主机额外安装软件所存放的目录</p><p><code>/var</code>：存放经常修改的目录，例如日志文件。</p><h2 id="VIM编辑器"><a href="#VIM编辑器" class="headerlink" title="VIM编辑器"></a>VIM编辑器</h2><h3 id="一般模式"><a href="#一般模式" class="headerlink" title="一般模式"></a>一般模式</h3><p><code>vim</code>执行之后就默认进入一般模式。</p><table><thead><tr><th align="center">语法</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">yy</td><td align="center">复制光标当前一行</td></tr><tr><td align="center">y 数字 y</td><td align="center">从当前行开始复制数字行</td></tr><tr><td align="center">y $</td><td align="center">从当前位置复制到此行末尾</td></tr><tr><td align="center">p</td><td align="center">粘贴到当前行的下一行</td></tr><tr><td align="center">dd</td><td align="center">删除当前行</td></tr><tr><td align="center">d 数字 d</td><td align="center">从当前行开始删除 数字行</td></tr><tr><td align="center">$</td><td align="center">移动到行尾</td></tr><tr><td align="center">^</td><td align="center">移动到行首</td></tr><tr><td align="center">y ^</td><td align="center">从当前行行首复制到当前位置的前一个</td></tr><tr><td align="center">y w</td><td align="center">从当前位置开始复制到单词结束</td></tr><tr><td align="center">d w</td><td align="center">从当前位置开始删除到单词结束</td></tr></tbody></table><h3 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h3><table><thead><tr><th align="center">按键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">i</td><td align="center">当前光标前</td></tr><tr><td align="center">a</td><td align="center">当前光标后</td></tr><tr><td align="center">o</td><td align="center">当前行的下一行</td></tr><tr><td align="center">I</td><td align="center">当前行的行首</td></tr><tr><td align="center">A</td><td align="center">当前行的行尾</td></tr><tr><td align="center">O</td><td align="center">当前行的下一行</td></tr></tbody></table><h3 id="指令模式"><a href="#指令模式" class="headerlink" title="指令模式"></a>指令模式</h3><table><thead><tr><th align="center">命令</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">:w</td><td align="center">保存</td></tr><tr><td align="center">:q</td><td align="center">退出</td></tr><tr><td align="center">:!</td><td align="center">强制退出</td></tr><tr><td align="center">&#x2F;要查找的词</td><td align="center">n 查找下一个，N 往上查找</td></tr><tr><td align="center">:noh</td><td align="center">取消高亮显示</td></tr><tr><td align="center">:set nu</td><td align="center">显示行号</td></tr><tr><td align="center">:set nonu</td><td align="center">关闭行号</td></tr><tr><td align="center">:%s&#x2F;old&#x2F;new&#x2F;g</td><td align="center">替换内容 &#x2F;g 替换匹配到的所有内容</td></tr></tbody></table><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h3><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start|stop|restart|status 服务名</span><br></pre></td></tr></table></figure><p>服务存储在 <code>/usr/lib/systemd/system</code>中</p><h3 id="关机重启命令"><a href="#关机重启命令" class="headerlink" title="关机重启命令"></a>关机重启命令</h3><table><thead><tr><th align="center">命令</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">sync</td><td align="center">将数据由内存同步到硬盘中</td></tr><tr><td align="center">halt</td><td align="center">停机但不断电</td></tr><tr><td align="center">poweroff</td><td align="center">关机</td></tr><tr><td align="center">reboot</td><td align="center">重启</td></tr></tbody></table><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><h4 id="man"><a href="#man" class="headerlink" title="man"></a>man</h4><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man [命令或配置文件]</span><br></pre></td></tr></table></figure><p>显示说明：</p><table><thead><tr><th align="center">信息</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">NAME</td><td align="center">命令的名称和单行描述</td></tr><tr><td align="center">SYNOPSIS</td><td align="center">怎样使用命令</td></tr><tr><td align="center">DESCRIPTION</td><td align="center">命令功能的深入讨论</td></tr><tr><td align="center">EXAMPLES</td><td align="center">怎样使用命令的例子</td></tr><tr><td align="center">SEE ALSO</td><td align="center">相关主题（通常是手册页）</td></tr></tbody></table><h4 id="help"><a href="#help" class="headerlink" title="help"></a>help</h4><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">help 命令</span><br></pre></td></tr></table></figure><h3 id="文件目录类命令"><a href="#文件目录类命令" class="headerlink" title="文件目录类命令"></a>文件目录类命令</h3><h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pwd # 显示当前目录的绝对路径</span><br></pre></td></tr></table></figure><h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls [选项][目录或文件] # 列出目录的内容</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">选项</th></tr></thead><tbody><tr><td align="center">-a</td><td align="center">包含隐藏文件一起显示</td></tr><tr><td align="center">-l</td><td align="center">包含文件的属性和权限信息一起显示</td></tr></tbody></table><p>显示说明：</p><p>文件类型、权限、链接数、文件属主、文件属组、文件大小（用byte 来表示）、建立或最近修改的时间、名字</p><h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd [参数] # 切换路径</span><br></pre></td></tr></table></figure><h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir [选项] 目录 # 创建目录</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-p</td><td align="center">创建多层目录</td></tr></tbody></table><h4 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rmdir 要删除的空目录 # 删除目录</span><br></pre></td></tr></table></figure><h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch 文件名称 # 创建文件</span><br></pre></td></tr></table></figure><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp [选项] source dest # 复制source文件到dest</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-r</td><td align="center">递归复制整个文件夹</td></tr></tbody></table><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm [选项] deleteFile  # 递归删除目录中所有内容</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-r</td><td align="center">递归删除目录中所有内容</td></tr><tr><td align="center">-f</td><td align="center">强制执行删除操作，而不提示用于进行确认</td></tr><tr><td align="center">-v</td><td align="center">显示指令的详细执行过程</td></tr></tbody></table><h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv oldNameFile newNameFile # 重命名</span><br><span class="line">mv /temp/movefile /targetFolder # 移动文件</span><br></pre></td></tr></table></figure><h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat [选项] 要查看的文件 # 查看文件</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-n</td><td align="center">显示行号</td></tr></tbody></table><h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">more 要查看的文件 # 查看文件</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">功能space</th></tr></thead><tbody><tr><td align="center">space</td><td align="center">代表向下翻一页</td></tr><tr><td align="center">enter</td><td align="center">代表向下翻一行</td></tr><tr><td align="center">q</td><td align="center">代表立刻离开 more ，不再显示该文件</td></tr><tr><td align="center">Ctrl+F</td><td align="center">向下滚动一屏</td></tr><tr><td align="center">Ctrl+B</td><td align="center">返回上一屏</td></tr><tr><td align="center">&#x3D;</td><td align="center">输出当前行的行号</td></tr><tr><td align="center">:f</td><td align="center">输出文件名和当前行的行号</td></tr></tbody></table><h4 id="less"><a href="#less" class="headerlink" title="less"></a>less</h4><p>less 指令在显示文件内容时，并不是一次将整个文件加载之后 才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。</p><table><thead><tr><th align="center">选项</th><th align="center">功能space</th></tr></thead><tbody><tr><td align="center">space</td><td align="center">代表向下翻一页</td></tr><tr><td align="center">pagedown</td><td align="center">代表向下翻一页</td></tr><tr><td align="center">pageup</td><td align="center">代表向上翻一页</td></tr><tr><td align="center">&#x2F;字串</td><td align="center">向下搜寻『字串』的功能；n：向下查找；N：向上查找</td></tr><tr><td align="center">?字串</td><td align="center">向上搜寻『字串』的功能；n：向上查找；N：向下查找</td></tr><tr><td align="center">q</td><td align="center">离开 less 这个程序</td></tr></tbody></table><h4 id="head"><a href="#head" class="headerlink" title="head"></a>head</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">head 文件 # 查看文件头10行内容</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">功能space</th></tr></thead><tbody><tr><td align="center">-n 行数</td><td align="center">指定显示头部内容的行数</td></tr></tbody></table><h4 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail 文件 # 查看文件尾部10行内容</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">功能space</th></tr></thead><tbody><tr><td align="center">-n 行数</td><td align="center">输出文件尾部 n 行内</td></tr><tr><td align="center">-f</td><td align="center">显示文件最新追加的内容，监视文件变化</td></tr></tbody></table><h4 id="gt-和-gt-gt"><a href="#gt-和-gt-gt" class="headerlink" title="&gt; 和 &gt;&gt;"></a>&gt; 和 &gt;&gt;</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l &gt; 文件 # 列表的内容写入文件 a.txt 中（覆盖写）</span><br><span class="line">ls -al &gt;&gt; 文件 # 列表的内容追加到文件 aa.txt 的末尾</span><br></pre></td></tr></table></figure><h4 id="ln-软连接"><a href="#ln-软连接" class="headerlink" title="ln 软连接"></a>ln 软连接</h4><p>软链接也称为符号链接，类似于 windows 里的快捷方式，有自己的数据块，主要存放 了链接其他文件的路径。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s [原文件或目录] [软链接名] # 给原文件创建一个软链接</span><br></pre></td></tr></table></figure><h3 id="用户管理类命令"><a href="#用户管理类命令" class="headerlink" title="用户管理类命令"></a>用户管理类命令</h3><h4 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd 用户名 # 添加新用户</span><br><span class="line">useradd -g 组名 用户名  # 添加新用户到某个组</span><br></pre></td></tr></table></figure><h4 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">passwd 用户名 # 设置用户密码</span><br></pre></td></tr></table></figure><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">id 用户名 # 查看用户是否存在</span><br></pre></td></tr></table></figure><h4 id="su"><a href="#su" class="headerlink" title="su"></a>su</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su 用户名称 # 切换用户，只能获得用户的执行权限，不能获得环境变量</span><br><span class="line">su - 用户名称  # 切换到用户并获得该用户的环境变量及执行权限</span><br></pre></td></tr></table></figure><h4 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">userdel 用户名 # 删除用户但保存用户主目录）</span><br><span class="line">userdel -r 用户名 # 用户和用户主目录，都删除</span><br></pre></td></tr></table></figure><h4 id="who"><a href="#who" class="headerlink" title="who"></a>who</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">whoami # 显示自身用户名称）</span><br><span class="line">who am i # 显示登录用户的用户名以及登陆时间</span><br></pre></td></tr></table></figure><h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">usermod -g 用户组 用户名 # 将用户加入到用户组</span><br></pre></td></tr></table></figure><h3 id="用户组管理命令"><a href="#用户组管理命令" class="headerlink" title="用户组管理命令"></a>用户组管理命令</h3><h4 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd 组名 # 新增一个组</span><br></pre></td></tr></table></figure><h4 id="groupdel"><a href="#groupdel" class="headerlink" title="groupdel"></a>groupdel</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupdel 组名 # 删除一个组</span><br></pre></td></tr></table></figure><h4 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupmod -n 新组名 老组名 # 修改组的名称</span><br></pre></td></tr></table></figure><h3 id="文件权限命令"><a href="#文件权限命令" class="headerlink" title="文件权限命令"></a>文件权限命令</h3><h4 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h4><img src="/archives/53d0684b/file-field.png" class title="文件属性"><p>0位表示类型，<code>-</code>表示文件，<code>d</code>表示目录，<code>l</code>连接文档</p><p>1~3位表示所有者的权限</p><p>4~6位表示与所有者同组的用户的权限</p><p>7~9位表示其他用户的权限</p><h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod [&#123;ugoa&#125;&#123;+-&#125;&#123;rwx&#125;] 文件或目录</span><br><span class="line">chmod [mode=421] 文件或目录</span><br></pre></td></tr></table></figure><h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown [选项] [最终用户] [文件或目录] # 改变文件或者目录的所有者</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-R</td><td align="center">递归操作</td></tr></tbody></table><h4 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chgrp [最终用户组] [文件或目录] # 改变文件或者目录的所属组</span><br></pre></td></tr></table></figure><h3 id="搜索查找类命令"><a href="#搜索查找类命令" class="headerlink" title="搜索查找类命令"></a>搜索查找类命令</h3><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find [搜索范围] [选项] # 将满足条件的文件显示在终端</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-name  &lt;查询方式&gt;</td><td align="center">按照指定的文件名查找模式查找文件</td></tr><tr><td align="center">-user &lt;用户名&gt;</td><td align="center">查找属于指定用户名所有文件</td></tr><tr><td align="center">-size &lt;文件大小&gt;</td><td align="center">按照指定的文件大小查找文件,单位为: b —— 块（512 字节） c —— 字节 w —— 字（2 字节） k —— 千字节 M —— 兆字节 G —— 吉字</td></tr></tbody></table><h4 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h4><p>locate 指令利用事先建立的系统中所有文件名称及路径的 locate 数据库实现快速定位给 定的文件。Locate 指令无需遍历整个文件系统，查询速度较快。</p><p>搜索文件之前必须执行过一次<code>updatedb</code>更新过数据库。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">locate 搜索文件</span><br></pre></td></tr></table></figure><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep 选项 查找内容 源文件</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-n</td><td align="center">显示匹配行及行号</td></tr></tbody></table><h3 id="压缩解压缩类命令"><a href="#压缩解压缩类命令" class="headerlink" title="压缩解压缩类命令"></a>压缩解压缩类命令</h3><h4 id="gzip-x2F-gunzip"><a href="#gzip-x2F-gunzip" class="headerlink" title="gzip&#x2F;gunzip"></a>gzip&#x2F;gunzip</h4><p>只能压缩文件不能压缩目录，不保留原来的文件，同时压缩多个文件会产生多个压缩包</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gzip 文件 # 压缩文件，只能将文件压缩为*.gz 文件</span><br><span class="line">gunzip 文件.gz  # 解压缩文件</span><br></pre></td></tr></table></figure><h4 id="zip-x2F-unzip"><a href="#zip-x2F-unzip" class="headerlink" title="zip&#x2F;unzip"></a>zip&#x2F;unzip</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zip [选项] XXX.zip 将要压缩的内容   # 压缩文件和目录的命令</span><br><span class="line">unzip [选项] XXX.zip             # 解压缩文件</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">zip选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-r</td><td align="center">压缩目录</td></tr></tbody></table><table><thead><tr><th align="center">unzip选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-d &lt;目录&gt;</td><td align="center">指定解压后文件的存放目录</td></tr></tbody></table><h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar [选项] XXX.tar.gz 将要打包进去的内容 # 打包目录，压缩后的文件格式.tar.gz</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-c</td><td align="center">产生.tar 打包文件</td></tr><tr><td align="center">-v</td><td align="center">显示详细信息</td></tr><tr><td align="center">-f</td><td align="center">指定压缩后的文件名</td></tr><tr><td align="center">-z</td><td align="center">打包同时压缩</td></tr><tr><td align="center">-x</td><td align="center">解包.tar 文件</td></tr><tr><td align="center">-C</td><td align="center">解压到指定目录</td></tr></tbody></table><h3 id="进程管理类命令"><a href="#进程管理类命令" class="headerlink" title="进程管理类命令"></a>进程管理类命令</h3><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -aux | grep xxx # 查看系统中所有进程</span><br><span class="line">ps -ef | grep xxx # 可以查看子父进程之间的关系</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-a</td><td align="center">列出带有终端的所有用户的进程</td></tr><tr><td align="center">-x</td><td align="center">列出当前用户的所有进程，包括没有终端的进程</td></tr><tr><td align="center">-u</td><td align="center">列出某个用户关联的所有进程</td></tr><tr><td align="center">-e</td><td align="center">列出所有进程</td></tr><tr><td align="center">-f</td><td align="center">显示完整格式的进程列表</td></tr></tbody></table><p><code>ps -aux</code> 显示信息说明，想查看进程CPU占用率和内存占用率，用<code>ps -aux</code></p><ul><li><p><code>USER</code>：该进程是由哪个用户产生的</p></li><li><p><code>PID</code>：进程号</p></li><li><p><code>%CPU</code>：进程占用CPU资源百分比</p></li><li><p><code>%MEM</code>：进程占用内存百分比</p></li><li><p><code>VSZ</code>：进程占用虚拟内存的大小，单位KB</p></li><li><p><code>RSS</code>：进程占用内存的大小，单位KB</p></li><li><p><code>TTY</code>：进程是在哪个终端中运行的 ，tty1 是图形化终端， tty2-tty6 是本地的字符界面终端。pts&#x2F;0-255 代表虚拟终端。</p></li><li><p><code>STAT</code>：进程状态，常见的状态有：R：运行状态、S：睡眠状态、T：暂停状态、 Z：僵尸状态、s：包含子进程、l：多线程、+：前台显示</p></li><li><p><code>START</code>：进程的启动时间</p></li><li><p><code>TIME</code>：进程占用CPU运算的时间</p></li><li><p><code>COMMAND</code>：产生此进程的命令名</p></li></ul><p><code>ps -ef</code> 显示信息说明，想查看进程的父进程ID，用<code>ps -ef</code></p><ul><li><code>UID</code>：该进程是由哪个用户产生的</li><li><code>PID</code>：进程号</li><li><code>PPID</code>：父进程进程号</li><li><code>C</code>：CPU 用于计算执行优先级的因子。数值越大，表明进程是 CPU 密集型运算， 执行优先级会降低；数值越小，表明进程是 I&#x2F;O 密集型运算，执行优先级会提高</li><li><code>STIME</code>：进程的启动时间</li><li><code>TTY</code>：进程是在哪个终端中运行的 ，tty1 是图形化终端， tty2-tty6 是本地的字符界面终端。pts&#x2F;0-255 代表虚拟终端。</li><li><code>CMD</code>：产生此进程的命令名</li></ul><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill [选项] 进程号 # 通过进程号杀死进程</span><br><span class="line">killall 进程名称 # 通过进程名称杀死进程，也支持通配符</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-9</td><td align="center">表示强迫进程立即停止</td></tr></tbody></table><h4 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pstree [选项]</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-p</td><td align="center">显示进程的 PI</td></tr><tr><td align="center">-u</td><td align="center">显示进程的所属用户</td></tr></tbody></table><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top [选项]</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-d 秒数</td><td align="center">指定 top 命令每隔几秒更新。默认是 3 秒在 top 命令的交互模式当 中可以执行的命令</td></tr><tr><td align="center">-i</td><td align="center">使 top 不显示任何闲置或者僵死进程。</td></tr><tr><td align="center">-p</td><td align="center">通过指定监控进程 ID 来仅仅监控某个进程的状态</td></tr></tbody></table><table><thead><tr><th align="center">操作</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">P</td><td align="center">以 CPU 使用率排序，默认就是此项</td></tr><tr><td align="center">M</td><td align="center">以内存的使用率排序</td></tr><tr><td align="center">N</td><td align="center">以 PID 排序</td></tr><tr><td align="center">q</td><td align="center">退出 to</td></tr></tbody></table><h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -anp | grep 进程号 # 查看该进程网络信息）</span><br><span class="line">netstat –nlp | grep 端口号 # 查看网络端口号占用情况）</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-n</td><td align="center">拒绝显示别名，能显示数字的全部转化成数字</td></tr><tr><td align="center">-p</td><td align="center">表示显示哪个进程在调用</td></tr><tr><td align="center">-a</td><td align="center">显示所有正在监听（listen）和未监听的套接字（socket</td></tr><tr><td align="center">-l</td><td align="center">仅列出在监听的服务状态</td></tr></tbody></table><h3 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h3><h4 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h4><p>RPM（RedHat Package Manager），RedHat软件包管理工具，类似windows里面的setup.exe 是Linux这系列操作系统里面的打包安装工具。</p><p>查询命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -qa # 查询所安装的所有 rpm 软件包</span><br></pre></td></tr></table></figure><p>卸载命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -e RPM软件包</span><br><span class="line">rpm -e --nodeps</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-e</td><td align="center">卸载软件包</td></tr><tr><td align="center">–nodeps</td><td align="center">卸载软件时，不检查依赖。</td></tr></tbody></table><p>安装命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -ivh RPM 包全名</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-i</td><td align="center">install，安装</td></tr><tr><td align="center">-v</td><td align="center">–verbose，显示详细信息</td></tr><tr><td align="center">-h</td><td align="center">–hash，进度条</td></tr><tr><td align="center">–nodeps</td><td align="center">安装前不检查依赖</td></tr></tbody></table><h4 id="YUM"><a href="#YUM" class="headerlink" title="YUM"></a>YUM</h4><p>YUM（全称为 Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 CentOS 中的 Shell 前端软件包管理器。基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包 并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次 次下载、安装。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum [选项] [参数]</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-y</td><td align="center">对所有提问都回答“yes”</td></tr></tbody></table><table><thead><tr><th align="center">参数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">install</td><td align="center">安装 rpm 软件</td></tr><tr><td align="center">update</td><td align="center">更新 rpm 软件</td></tr><tr><td align="center">check-update</td><td align="center">检查是否有可用的更新 rpm 软件</td></tr><tr><td align="center">remove</td><td align="center">删除指定的 rpm 软件</td></tr><tr><td align="center">list</td><td align="center">显示软件包信息</td></tr><tr><td align="center">clean</td><td align="center">清理 yum 过期的缓存</td></tr><tr><td align="center">deplist</td><td align="center">显示 yum 软件包的所有依赖关</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热题100-二分查找</title>
      <link href="/archives/83ba595b.html"/>
      <url>/archives/83ba595b.html</url>
      
        <content type="html"><![CDATA[<h3 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h3><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p><p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。<br>链接：<a href="https://leetcode.cn/problems/search-in-rotated-sorted-array">https://leetcode.cn/problems/search-in-rotated-sorted-array</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target == nums[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                right = left - <span class="number">1</span>;</span><br><span class="line">                left = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeft</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRight</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getLeft(nums, target);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getRight(nums, target);</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= right) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left, right&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 热题100 </category>
          
          <category> 二分查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/archives/bae4ff13.html"/>
      <url>/archives/bae4ff13.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据库相关命令"><a href="#数据库相关命令" class="headerlink" title="数据库相关命令"></a>数据库相关命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select index  切换数据库</span><br><span class="line">dbsize 查看当前数据库中的key的数量</span><br><span class="line">flushdb 清空当前数据库</span><br><span class="line">flushall 清空所有数据库</span><br></pre></td></tr></table></figure><h2 id="Key相关命令"><a href="#Key相关命令" class="headerlink" title="Key相关命令"></a>Key相关命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keys pattern 查看当前库中匹配pattern的key</span><br><span class="line">exists key [key ...] 判断key是否存在</span><br><span class="line">type key 查看key对应的value的类型</span><br><span class="line">del key [key ...] 删除指定的key</span><br><span class="line">unlink key [key ...] 非阻塞删除key（异步删除）</span><br><span class="line">expire key seconds 设置key的过期时间</span><br><span class="line">tll key 查看key的过期时间  -1表示永不过期、-2表示已经过期</span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>String类型是二进制安全的，可以包含任何数据。最大是512M。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set key value 添加键值对，会覆盖</span><br><span class="line">setnx key value 只有当key不存在时，才会添加</span><br><span class="line">get key 获取value值</span><br><span class="line">append key value 将value添加到原来的value的后面</span><br><span class="line">strlen key 获取value的长度</span><br><span class="line">incr key 将value值+1</span><br><span class="line">decr kye 将value值-1</span><br><span class="line">incrby key increment 将value值+increment</span><br><span class="line">decrby key decrement 将value值-decrement</span><br><span class="line">mset key valiue [key value ...] 同时添加多个键值对</span><br><span class="line">msetnx key valiue [key value ...] 同时添加多个键值对,只有当key不存在时，才会添加</span><br><span class="line">mget key [key ...] 同时获取多个value值</span><br><span class="line">getrange key key end 截取value值</span><br><span class="line">setrange key offset value k1 从offset开始用value覆盖原来的值</span><br><span class="line">setex key seconds value 添加键值对时同时设置过期时间</span><br><span class="line">getset key value 现获取旧值在设置新值</span><br></pre></td></tr></table></figure><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lpush/rpush  key element [element ...] 从左边/右边插入一个或多个值。</span><br><span class="line">lpop/rpop  key [count] 从左边/右边吐出count个值。值在键在，值光键亡。</span><br><span class="line">rpoplpush  source destination 从source列表右边吐出一个值，插到destination列表左边</span><br><span class="line">lrange key start stop  按照索引下标获得元素(从左到右) stop=-1时表示所有元素</span><br><span class="line">lindex key index 按照索引下标获得元素(从左到右)</span><br><span class="line">llen key 获得列表长度 </span><br><span class="line">linsert key BEFORE|AFTER pivot element 在pivot元素的前面或者后面插入element元素</span><br><span class="line">lrem key count element 从左边删除count个element元素</span><br><span class="line">lset key index element 将列表key下标为index的值替换成element</span><br></pre></td></tr></table></figure><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sadd key member [member ...] 创建set</span><br><span class="line">smembers key 取出该集合的所有值。sinter</span><br><span class="line">sismember key member 判断集合key是否为含有该member，有1，没有0</span><br><span class="line">scard key 返回该集合的元素个数</span><br><span class="line">srem key member [member ...] 删除集合中的某些元素</span><br><span class="line">spop key [count] 随机从该集合中吐出count个元素</span><br><span class="line">srandmember key [count] 随机从该集合中取出count个值。不会从集合中sdiff删s除 。</span><br><span class="line">smove source destination member 把source集合中member移动到destination</span><br><span class="line">sinter key [key ...] 返回集合的交集元素。</span><br><span class="line">sunion key [key ...] 返回两个集合的并集元素。</span><br><span class="line">sdiff key [key ...] 返回在第一个集合中但不在后面集合中的元素</span><br></pre></td></tr></table></figure><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hset key field value [field value ...]  给key所对应的哈希表中添加若干键值对</span><br><span class="line">hget key field 从key所对应的哈希表中取出 value </span><br><span class="line">hmset key field value [field value ...] 批量设置hash的值</span><br><span class="line">hexists key field 查看哈希表中，field是否存在。 </span><br><span class="line">hkeys key 列出该哈希表中的所有field</span><br><span class="line">hvals key 列出该哈希表中的所有value</span><br><span class="line">hincrby key field increment 为哈希表中的field的value加上增量 1   -1</span><br><span class="line">hsetnx key field value 将哈希表中的field的值设置为value ，当且仅当域 field 不存在</span><br></pre></td></tr></table></figure><h2 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>每个member都关联了一个score，按照score升序对member进行排序。</p><h3 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zadd key [NX|XX] [GT|LT] [CH] [INCR] score member [score member ...] 将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</span><br><span class="line"></span><br><span class="line">zrange key min max [BYSCORE|BYLEX] [REV] [LIMIT offset count] [WITHSCORES]</span><br><span class="line">返回有序集中，下标在 min~ max之间的元素。带WITHSCORES，可以让分数一起和值返回到结果集。</span><br><span class="line"></span><br><span class="line">zrangebyscore key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line">同上，但逆序。</span><br><span class="line"></span><br><span class="line">zrangebyscore key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line">返回有序集中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。 </span><br><span class="line"></span><br><span class="line">zrevrangebyscore key max min [WITHSCORES] [LIMIT offset count]      同上，改为从大到小排列。 </span><br><span class="line"></span><br><span class="line">zincrby key increment member 为member元素的score加上increment</span><br><span class="line"></span><br><span class="line">zrem key member [member ...] 删除集合中的member</span><br><span class="line"></span><br><span class="line">zcount key min max 统计该集合，分数区间[min,max]的元素个数 </span><br><span class="line"></span><br><span class="line">zrank key member 返回该值在集合中的排名，从0开始。</span><br></pre></td></tr></table></figure><h2 id="发布和订阅"><a href="#发布和订阅" class="headerlink" title="发布和订阅"></a>发布和订阅</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subscribe channel[channel ...] 订阅频道</span><br><span class="line"></span><br><span class="line">publish channel message 向频道中发送消息</span><br></pre></td></tr></table></figure><h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h2><h3 id="常用命令-5"><a href="#常用命令-5" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setbit key offset value 置Bitmaps中某个偏移量的值（0或1）</span><br><span class="line"></span><br><span class="line">getbit key offset 获取Bitmaps中某个偏移量的值</span><br><span class="line"></span><br><span class="line">bitcount key [start end] 统计字符串从start字节到end字节比特值为1的数量</span><br><span class="line"></span><br><span class="line">bitop operation destkey key [key ...] </span><br><span class="line">对一个或多个bitnmap做操作，结果为 destkey 对应的bitmap,operation有 or and xor not</span><br></pre></td></tr></table></figure><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>HyperLogLog只会根据输入元素记录不重复的个数，而不会去存储元素。</p><h3 id="常用命令-6"><a href="#常用命令-6" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pfadd key element [element ...]  添加指定元素到 HyperLogLog 中</span><br><span class="line"></span><br><span class="line">pfcount key [key ...] 获得不重复的个数</span><br><span class="line"></span><br><span class="line">pfmerge destkey sourcekey [sourcekey ...] 合并sourcekey得到destkey</span><br></pre></td></tr></table></figure><h2 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h2><h3 id="常用命令-7"><a href="#常用命令-7" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">geoadd key [NX|XX] [CH] longitude latitude member [longitude latitude member ...]</span><br><span class="line">添加地理位置（经度，纬度，名称）</span><br><span class="line"></span><br><span class="line">geopos key member [member ...] 获得指定地区的坐标值</span><br><span class="line"></span><br><span class="line">geodist key member1 member2 [m|km|ft|mi] 获取两个位置之间的直线距离</span><br><span class="line"></span><br><span class="line">georadius key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC|DESC] [STORE key] [STOREDIST key]</span><br><span class="line">以给定的经纬度为中心，找出某一半径内的元素</span><br></pre></td></tr></table></figure><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>连接池</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig,</span><br><span class="line">                <span class="string">&quot;81.68.102.239&quot;</span>,<span class="number">6379</span>,<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getjedis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span>  <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        jedis = JedisConnectionFactory.getjedis();</span><br><span class="line">        jedis.auth(<span class="string">&quot;******&quot;</span>);</span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">        jedis.hset(<span class="string">&quot;user:1&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;wjy&quot;</span>);</span><br><span class="line">        jedis.hset(<span class="string">&quot;user:1&quot;</span>,<span class="string">&quot;age&quot;</span>, <span class="string">&quot;22&quot;</span>);</span><br><span class="line">        Map&lt;String, String&gt; map = jedis.hgetAll(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;wjy&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a>SpringDataRedis</h2><h3 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h3><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Redis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--jackson--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">81.68</span><span class="number">.102</span><span class="number">.239</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">*****</span></span><br></pre></td></tr></table></figure><p>配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 创建JSON序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置Value的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实体类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringdataRedisDemoApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,Object&gt; redisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;wjy&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;user:100&quot;</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;wjy&quot;</span>,<span class="number">22</span>));</span><br><span class="line">        <span class="type">User</span> <span class="variable">o</span> <span class="operator">=</span> (User) redisTemplate.opsForValue().get(<span class="string">&quot;user:100&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;o = &quot;</span> + o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a>StringRedisTemplate</h3><p>测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringRedisTemplateTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;wjy&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;wjy&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:100&quot;</span>, json);</span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:100&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;user1 = &quot;</span> + user1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿问题也热点Key问题，就是一个被高并发访问且缓存重建业务较复杂的Key突然失效了，无数的请求会在瞬间给数据库带来巨大的冲击。</p><img src="/archives/bae4ff13/jichuan.png" class title="互斥锁和逻辑过期"><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会被打倒数据库。</p><h3 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h3><img src="/archives/bae4ff13/chuantou-null.png" class title="缓存空对象"><h3 id="布隆过滤"><a href="#布隆过滤" class="headerlink" title="布隆过滤"></a>布隆过滤</h3><img src="/archives/bae4ff13/chuantou-bool.png" class title="布隆过滤"><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>解决方案：</p><ul><li>给不同的key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java开发框架 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热题100-前缀和</title>
      <link href="/archives/1128e073.html"/>
      <url>/archives/1128e073.html</url>
      
        <content type="html"><![CDATA[<h2 id="和为K的子数组"><a href="#和为K的子数组" class="headerlink" title="和为K的子数组"></a>和为K的子数组</h2><p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数 。<br>链接：<a href="https://leetcode.cn/problems/subarray-sum-equals-k">https://leetcode.cn/problems/subarray-sum-equals-k</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum[i] = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i-<span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                sum[i] += sum[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            res += map.getOrDefault(sum[i] - k, <span class="number">0</span>);</span><br><span class="line">            map.put(sum[i], map.getOrDefault(sum[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 热题100 </category>
          
          <category> 前缀和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热题100-位运算</title>
      <link href="/archives/1b295250.html"/>
      <url>/archives/1b295250.html</url>
      
        <content type="html"><![CDATA[<h2 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？<br>链接：<a href="https://leetcode.cn/problems/single-number">https://leetcode.cn/problems/single-number</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            res ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 热题100 </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热题100-DFS</title>
      <link href="/archives/d62b7da6.html"/>
      <url>/archives/d62b7da6.html</url>
      
        <content type="html"><![CDATA[<h2 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。<br>链接：<a href="https://leetcode.cn/problems/number-of-islands">https://leetcode.cn/problems/number-of-islands</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">int</span>[] dx = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] dy = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> dx[k] + i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> dy[k] + j;</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; grid.length &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; grid[<span class="number">0</span>].length &amp;&amp; grid[x][y] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                dfs(grid, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 热题100 </category>
          
          <category> DFS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热题100-二叉树</title>
      <link href="/archives/f117013c.html"/>
      <url>/archives/f117013c.html</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。<br>链接：<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree">https://leetcode.cn/problems/maximum-depth-of-binary-tree</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 每个节点都返回自己的最大深度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// x的最大深度就等于 1 + max(左子树最大深度,右子树最大深度)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(dfs(x.left), dfs(x.right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>  dfs(root);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。<br>链接：<a href="https://leetcode.cn/problems/diameter-of-binary-tree">https://leetcode.cn/problems/diameter-of-binary-tree</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="type">int</span> diameter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Info</span><span class="params">(<span class="type">int</span> height, <span class="type">int</span> diameter)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.diameter = diameter; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Info <span class="title function_">dfs</span><span class="params">(TreeNode x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Info</span> <span class="variable">leftInfo</span> <span class="operator">=</span> dfs(x.left);</span><br><span class="line">        <span class="type">Info</span> <span class="variable">rightInfo</span> <span class="operator">=</span> dfs(x.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> Math.max(leftInfo.height, rightInfo.height) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">diameter</span> <span class="operator">=</span> Math.max(Math.max(leftInfo.diameter, rightInfo.diameter), <span class="number">1</span> + leftInfo.height  + rightInfo.height);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(height, diameter);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root).diameter-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>链接：<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h3><p>给你两棵二叉树： root1 和 root2 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p>注意: 合并过程必须从两个树的根节点开始。<br>链接：<a href="https://leetcode.cn/problems/merge-two-binary-trees">https://leetcode.cn/problems/merge-two-binary-trees</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span>) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="literal">null</span>) <span class="keyword">return</span> root1;</span><br><span class="line">        root1.val += root2.val;</span><br><span class="line">        root1.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">        root1.right = mergeTrees(root1.right, root2.right);</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 热题100 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/archives/0.html"/>
      <url>/archives/0.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装Docker（基于CentOS-8-0）"><a href="#安装Docker（基于CentOS-8-0）" class="headerlink" title="安装Docker（基于CentOS 8.0）"></a>安装Docker（基于CentOS 8.0）</h2><h3 id="卸载旧版本Docker-非必须"><a href="#卸载旧版本Docker-非必须" class="headerlink" title="卸载旧版本Docker(非必须)"></a>卸载旧版本Docker(非必须)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine \</span><br><span class="line">                  docker-ce</span><br></pre></td></tr></table></figure><h3 id="安装yum工具"><a href="#安装yum工具" class="headerlink" title="安装yum工具"></a>安装yum工具</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm2 --skip-broken</span><br></pre></td></tr></table></figure><h3 id="更新本地镜像源"><a href="#更新本地镜像源" class="headerlink" title="更新本地镜像源"></a>更新本地镜像源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置docker镜像源</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">    </span><br><span class="line">sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line">dnf makecache</span><br></pre></td></tr></table></figure><h3 id="安装社区版"><a href="#安装社区版" class="headerlink" title="安装社区版"></a>安装社区版</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure><h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">禁止开机启动防火墙</span></span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure><h3 id="启动Docker"><a href="#启动Docker" class="headerlink" title="启动Docker"></a>启动Docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker  # 启动docker服务</span><br><span class="line"></span><br><span class="line">systemctl stop docker  # 停止docker服务</span><br><span class="line"></span><br><span class="line">systemctl restart docker  # 重启docker服务</span><br></pre></td></tr></table></figure><h3 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://jlypyoty.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="初识Docker"><a href="#初识Docker" class="headerlink" title="初识Docker"></a>初识Docker</h2><h3 id="Docker如何解决项目依赖关系复杂，不同组件依赖的兼容性问题"><a href="#Docker如何解决项目依赖关系复杂，不同组件依赖的兼容性问题" class="headerlink" title="Docker如何解决项目依赖关系复杂，不同组件依赖的兼容性问题"></a>Docker如何解决项目依赖关系复杂，不同组件依赖的兼容性问题</h3><ul><li>Docker允许将应用、依赖、函数库、配置一起打包，形成可以移植镜像。</li><li>Docker应用运行在容器中，使用沙箱机制，相互隔离。</li></ul><h3 id="Docker如何解决开发、测试、生成环境有差异问题"><a href="#Docker如何解决开发、测试、生成环境有差异问题" class="headerlink" title="Docker如何解决开发、测试、生成环境有差异问题"></a>Docker如何解决开发、测试、生成环境有差异问题</h3><ul><li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意的Linxu操作系统上运行。</li></ul><h3 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a>镜像（Image）</h3><p>将应用程序及其所需的依赖、、函数库、配置等文件打包在一起，成为镜像。</p><h3 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h3><p>镜像中的应用程序运行后形成的进程就是容器。一个镜像可以运行多个容器。</p><h3 id="Docker结构："><a href="#Docker结构：" class="headerlink" title="Docker结构："></a>Docker结构：</h3><p>客户端：发送命令或者请求到Docker服务端。</p><p>服务端：接受命令或者远程请求，操作镜像或者容器。</p><h2 id="Docker基本操作"><a href="#Docker基本操作" class="headerlink" title="Docker基本操作"></a>Docker基本操作</h2><h3 id="镜像操作命令"><a href="#镜像操作命令" class="headerlink" title="镜像操作命令"></a>镜像操作命令</h3><img src="/archives/0/op-images.png" class title="镜像操作命令"><h3 id="容器操作命令"><a href="#容器操作命令" class="headerlink" title="容器操作命令"></a>容器操作命令</h3><img src="/archives/0/op-container.png" class title="镜像操作命令"><h3 id="docker-run常见参数"><a href="#docker-run常见参数" class="headerlink" title="docker run常见参数"></a>docker run常见参数</h3><ul><li><code>--name</code> ：指定容器名称</li><li><code>-p</code>：指定端口映射</li><li><code>-d</code>：让容器后台运行</li></ul><h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p>数据卷是为了将容器与数据分离，解耦合，方便操作容器内数据。</p><p>数据卷操作：</p><ul><li><p><code>docker volume create</code></p></li><li><p><code>docker volume ls</code></p></li><li><p><code>docker volume inspect</code></p></li><li><p><code>docker volume rm</code></p></li><li><p><code>docker volume prune</code></p></li><li><p><code>docker run --name xxx -v html:/root/html -p 80:80 sss</code> 将数据卷<code>html</code>与容器内<code>/root/html</code>关联起来</p></li></ul><p>直接挂载：</p><p><code>-v [宿主机目录]:[容器内目录]</code></p><p><code>-v [宿主机文件]:[容器内文件]</code></p><h2 id="Dockerfile自定义镜像"><a href="#Dockerfile自定义镜像" class="headerlink" title="Dockerfile自定义镜像"></a>Dockerfile自定义镜像</h2><h3 id="镜像结构"><a href="#镜像结构" class="headerlink" title="镜像结构"></a>镜像结构</h3><ul><li>Entrypoint: 入口，是镜像中应用启动的命令</li><li>其他: 在BaseImage基础上添加依赖，安装程序，完成整个应用的安装和配置</li><li>BaseImage层：包含基本的系统函数库，环境变量，文件系统</li></ul><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>Dockerfile就是一个文本文件，其中包含一个个的指令(Instruction)，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。Dockerfile的 第一行必须是FROM，从一个基础镜像来构建，基础镜像可以是基本操作系统，如Ubuntun。也可以是他人制作好的镜像，如：java:8-alpine</p><table><thead><tr><th align="center">指令</th><th align="center">说明</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">FROM</td><td align="center">指定基础镜像</td><td align="center">FROM centos:6</td></tr><tr><td align="center">ENV</td><td align="center">设置环境变量，可在后面指令使用</td><td align="center">ENV key value</td></tr><tr><td align="center">COPY</td><td align="center">拷贝本地文件到镜像的指定目录</td><td align="center">COPY .&#x2F;mysql-5.7.rpm &#x2F;tmp</td></tr><tr><td align="center">RUN</td><td align="center">执行Linux的shell命令，一般是安装过程的命令</td><td align="center">RUN yum install gcc</td></tr><tr><td align="center">EXPOSE</td><td align="center">指定容器运行时监听的端口，是给镜像使用者看的</td><td align="center">EXPOSE 8080</td></tr><tr><td align="center">ENTRYPOINT</td><td align="center">镜像中应用的启动命令，容器运行时调用</td><td align="center">ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><p>官方文档：<a href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></p><h2 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>DockerCompose可以基于Compose文件快速部署分布式应用，而无需一个个创建和运行容器。</p><p>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。</p><p>DockerCompose的详细语法参考：<a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>下载docker-compose文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>修改文件权限</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>自动补全命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java开发框架 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热题100-快速排序</title>
      <link href="/archives/94d1351a.html"/>
      <url>/archives/94d1351a.html</url>
      
        <content type="html"><![CDATA[<h2 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// partition函数每次返回一个确定好位置元素的下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[left];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] &lt;= pivot) right--;</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] &gt;= pivot) left++;</span><br><span class="line">            nums[right] = nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = pivot;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 返回一个确定好位置的元素的下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> partition(nums, left, right);</span><br><span class="line">            <span class="comment">// 如果下标就是k-1,表示此元素就是第K个最大的数</span></span><br><span class="line">            <span class="keyword">if</span> (pos == k-<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[pos];</span><br><span class="line">            <span class="comment">// 如果下标小于k-1,则要找的元素在当前元素的后边，left = pos + 1;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos &lt; k-<span class="number">1</span>) &#123;</span><br><span class="line">                left = pos + <span class="number">1</span>;    </span><br><span class="line">             <span class="comment">// 如果下标大于k-1,则要找的元素在当前元素的前边，right = pos - 1;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = pos - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10001</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前K个高频元素"><a href="#前K个高频元素" class="headerlink" title="前K个高频元素"></a>前K个高频元素</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p>链接：<a href="https://leetcode.cn/problems/top-k-frequent-elements/">https://leetcode.cn/problems/top-k-frequent-elements/</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> cnt)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val; </span><br><span class="line">        <span class="built_in">this</span>.cnt = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(Node[] nodes, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pivot</span> <span class="operator">=</span> nodes[left];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nodes[right].cnt &lt;= pivot.cnt) right--;</span><br><span class="line">            nodes[left] = nodes[right];</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nodes[left].cnt &gt;= pivot.cnt) left++;</span><br><span class="line">            nodes[right] = nodes[left];</span><br><span class="line">        &#125;</span><br><span class="line">        nodes[left] = pivot;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            map.put(nums[i], map.getOrDefault(nums[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Set&lt;Integer&gt; keys = map.keySet();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> keys.size();</span><br><span class="line">        Node[] nodes = <span class="keyword">new</span> <span class="title class_">Node</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer key : keys) &#123;</span><br><span class="line">            nodes[i++] = <span class="keyword">new</span> <span class="title class_">Node</span>(key, map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> partition(nodes, left, right);</span><br><span class="line">            <span class="keyword">if</span> (pos == k-<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                    res[i] = nodes[i].val;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos &lt; k-<span class="number">1</span>) &#123;</span><br><span class="line">                left = pos + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = pos - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 热题100 </category>
          
          <category> 快速排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/archives/bd3bd519.html"/>
      <url>/archives/bd3bd519.html</url>
      
        <content type="html"><![CDATA[<h2 id="Git工作流程图"><a href="#Git工作流程图" class="headerlink" title="Git工作流程图"></a>Git工作流程图</h2><img src="/archives/bd3bd519/git-process.png" class title="git工作流程"><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>配置用户名和邮箱</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name wangjiayu</span><br><span class="line">git config --global user.email wangjiayu19991126@63.com</span><br></pre></td></tr></table></figure><p>配置常用命令的别名</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch ~/.bashrc</span><br></pre></td></tr></table></figure><p>在<code>~/.bashrc</code>文件中编写脚本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias git-log=&#x27;git log --pretty=oneline --all --graph --abbrev-commit&#x27;</span><br><span class="line">alias ll=&#x27;ls -al&#x27;</span><br></pre></td></tr></table></figure><p>执行脚本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><h3 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h3><p>查看工作区和暂存区的状态（工作区是否有内容未加入暂存区、暂存区是否有内容未加入仓库）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><h3 id="加入暂存区"><a href="#加入暂存区" class="headerlink" title="加入暂存区"></a>加入暂存区</h3><p>将工作区的某些文件加入暂存区</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git add filename</span><br></pre></td></tr></table></figure><h3 id="加入（提交）本地仓库"><a href="#加入（提交）本地仓库" class="headerlink" title="加入（提交）本地仓库"></a>加入（提交）本地仓库</h3><p>将暂存区的内容加入（提交）到本地仓库</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;注释，解释此次提交的内容&quot;</span><br></pre></td></tr></table></figure><h3 id="查看提交日志"><a href="#查看提交日志" class="headerlink" title="查看提交日志"></a>查看提交日志</h3><p>查看本地仓库的日志</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log[option]</span><br></pre></td></tr></table></figure><ul><li>option<ul><li>–all 显示所有分支</li><li>–pretty&#x3D;oneline 将提交信息显示为一行</li><li>–abbrev-commit 使输出的commitID更短</li><li>–graph 以图的形式显示</li></ul></li></ul><p>查看HEAD指针的移动历史</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard commitID</span><br></pre></td></tr></table></figure><h3 id="指定文件不被git管理"><a href="#指定文件不被git管理" class="headerlink" title="指定文件不被git管理"></a>指定文件不被git管理</h3><p>指定文件在执行<code>git add .</code>命令时，不被加入到暂存区</p><p>在工作目录中创建<code>.gitignore</code>文件，文件中指明要忽略的文件。</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h3 id="查看本地分支"><a href="#查看本地分支" class="headerlink" title="查看本地分支"></a>查看本地分支</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><h3 id="创建本地分支"><a href="#创建本地分支" class="headerlink" title="创建本地分支"></a>创建本地分支</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch branchname</span><br></pre></td></tr></table></figure><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><p>切换到已有分支</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout branchname</span><br></pre></td></tr></table></figure><p> 支持切换到不存在的分支</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b branchname</span><br></pre></td></tr></table></figure><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>将<code>branchname</code>合并到当前分支</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge branchname</span><br></pre></td></tr></table></figure><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>删除分支时，会检查被删除的分支的有没有merge到别的分支，如果没有不让删除</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -d branchname</span><br></pre></td></tr></table></figure><p>强制删除分支</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -D branchname</span><br></pre></td></tr></table></figure><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>当两个分支上对文件的修改可能会产生冲突，比如，同时修改一个文件的同一行，此时执行<code>merge</code>指令时会提示不能自动合并，需手动解决冲突之后，再尝试合并。</p><h3 id="分支使用原则"><a href="#分支使用原则" class="headerlink" title="分支使用原则"></a>分支使用原则</h3><img src="/archives/bd3bd519/branch-use.png" class title="分支使用原则"><ul><li>master分支： 主分支，线上分支，线上运行的应用对应的分支</li><li>develop分支：开发分支，从master创建的分支，阶段开发完成之后，合并到master分支</li><li>feature&#x2F;xxx分支：从develop创建的分支，阶段开发完成之后，合并到develop分支</li><li>hotfix&#x2F;xxx分支：从master创建的分支，阶段开发完成之后，合并到develop、master、test分支</li></ul><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="配置SSH公钥"><a href="#配置SSH公钥" class="headerlink" title="配置SSH公钥"></a>配置SSH公钥</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>命令执行后公钥会存储在<code>~/.ssh/id_rsa.pub</code>中，复制到github中</p><p>验证是否配置成功</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add &lt;远程仓库名称&gt; &lt;仓库路径&gt;</span><br><span class="line">git remote add origin git@github.com:wangjiayu1126/test.git</span><br></pre></td></tr></table></figure><h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure><h3 id="本地仓库推送到远程仓库"><a href="#本地仓库推送到远程仓库" class="headerlink" title="本地仓库推送到远程仓库"></a>本地仓库推送到远程仓库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add [-f][--set-upstream] [远程仓库名称 [本地分支名称]:[远程分支名称]]</span><br></pre></td></tr></table></figure><p>如果远程分支名和本地分支名称相同，则可以只写本地分支</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p><code>-f</code>表示强制覆盖</p><p><code>--set -upstream</code> 建立分支之间的关联关系</p><p>如果已有关联关系可以直接</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><h3 id="分支之间的关联关系"><a href="#分支之间的关联关系" class="headerlink" title="分支之间的关联关系"></a>分支之间的关联关系</h3><p>查看分支之间的关联关系</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure><h3 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h3><p>如果不写本地目录名称，则目录名称会默认为远程仓库的名称</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone &lt;仓库路径&gt; [本地目录名称]</span><br></pre></td></tr></table></figure><h3 id="拉取和抓取"><a href="#拉取和抓取" class="headerlink" title="拉取和抓取"></a>拉取和抓取</h3><p>抓取就是将远程仓库的更新抓取到本地，但不合并。如果不指定分支会抓取所有分支。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch [remote_name] [branch_name]</span><br></pre></td></tr></table></figure><p>抓取就是将远程仓库的更新抓取到本地并且合并。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull [remote_name] [branch_name]</span><br></pre></td></tr></table></figure><h2 id="IDEA中使用Git"><a href="#IDEA中使用Git" class="headerlink" title="IDEA中使用Git"></a>IDEA中使用Git</h2><img src="/archives/bd3bd519/git-idea-01.png" class title="git工作流程"><img src="/archives/bd3bd519/git-idea-02.png" class title="git工作流程">]]></content>
      
      
      <categories>
          
          <category> Java开发框架 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热题100-设计</title>
      <link href="/archives/70524182.html"/>
      <url>/archives/70524182.html</url>
      
        <content type="html"><![CDATA[<h3 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h3><p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：<br>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。<br>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。<br>链接：<a href="https://leetcode.cn/problems/lru-cache">https://leetcode.cn/problems/lru-cache</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    HashMap&lt;Integer, Node&gt; map;    </span><br><span class="line">    Node head;</span><br><span class="line">    Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">delete</span> <span class="operator">=</span> tail.left;</span><br><span class="line">        tail.left.left.right = tail;</span><br><span class="line">        tail.left = tail.left.left;</span><br><span class="line">        <span class="keyword">return</span> delete;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Node s)</span> &#123;</span><br><span class="line">        s.left.right = s.right;</span><br><span class="line">        s.right.left = s.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertHead</span><span class="params">(Node s)</span> &#123;</span><br><span class="line">        s.right = head.right;</span><br><span class="line">        s.left = head;</span><br><span class="line">        head.right = s;</span><br><span class="line">        s.right.left = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        head.right = tail;</span><br><span class="line">        tail.left = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">            remove(s);</span><br><span class="line">            insertHead(s);</span><br><span class="line">            <span class="keyword">return</span> s.value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">            s.value = value;</span><br><span class="line">            remove(s);</span><br><span class="line">            insertHead(s);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.size() == capacity) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">delete</span> <span class="operator">=</span> removeLast();</span><br><span class="line">                map.remove(delete.key);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">            map.put(key, newNode);</span><br><span class="line">            insertHead(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 热题100 </category>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/archives/c35c5deb.html"/>
      <url>/archives/c35c5deb.html</url>
      
        <content type="html"><![CDATA[<h2 id="Maven的作用"><a href="#Maven的作用" class="headerlink" title="Maven的作用"></a>Maven的作用</h2><ol><li>项目构建：提供标准的、跨平台的自动化项目构建方式</li><li>依赖管理：管理项目依赖的资源（jar包）</li><li>统一开发结构：提供统一的项目结构</li></ol><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>仓库就是用来存储项目的（一个项目中可能会有多个jar包）</p><p>仓库分类：</p><ul><li>本地仓库，自己电脑上的仓库，连接远程仓库获取jar包</li><li>远程仓库：<ul><li>中央仓库：Maven团队维护的仓库</li><li>私服：公司的仓库，可能有自己公司做的jar包，不对外开放</li></ul></li></ul><h2 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h2><p>坐标就是描述项目在哪的</p><p>坐标的组成：</p><ul><li>groupId: 项目属于的组织</li><li>artifactId: 当前项目的名称</li><li>version: 版本号</li></ul><h2 id="配置仓库"><a href="#配置仓库" class="headerlink" title="配置仓库"></a>配置仓库</h2><h3 id="配置本地仓库"><a href="#配置本地仓库" class="headerlink" title="配置本地仓库"></a>配置本地仓库</h3><p>在conf文件夹中修改settings.xml文件，在其中添加</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:/mvnrep<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置远程仓库"><a href="#配置远程仓库" class="headerlink" title="配置远程仓库"></a>配置远程仓库</h3><p>在conf文件夹中修改settings.xml文件，在其中添加</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Maven工程目录结构"><a href="#Maven工程目录结构" class="headerlink" title="Maven工程目录结构"></a>Maven工程目录结构</h2><ul><li>project<ul><li>src<ul><li>main<ul><li>java</li><li>resources</li></ul></li><li>test<ul><li>java</li><li>resources</li></ul></li></ul></li><li>pom.xml</li></ul></li></ul><h2 id="Maven项目构建命令"><a href="#Maven项目构建命令" class="headerlink" title="Maven项目构建命令"></a>Maven项目构建命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn compile     # 编译 生成target/classes中的class文件</span><br><span class="line">mvn clean       # 清理 清理 target文件夹</span><br><span class="line">mvn test        # 测试</span><br><span class="line">mvn package     # 打包</span><br><span class="line">mvn install     # 安装到本地仓库， 将项目放到本地仓库中</span><br></pre></td></tr></table></figure><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><h3 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h3><p>直接依赖： 当前项目中通过配置建立的依赖关系</p><p>间接依赖：如果直接依赖的资源又依赖了其他资源，就是间接依赖</p><h3 id="依赖冲突问题"><a href="#依赖冲突问题" class="headerlink" title="依赖冲突问题"></a>依赖冲突问题</h3><p>路径优先：当依赖中出现相同的资源时，层级越深，优先级越低</p><p>声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的</p><h3 id="可选依赖"><a href="#可选依赖" class="headerlink" title="可选依赖"></a>可选依赖</h3><p>可选依赖会对外隐藏当前所依赖的资源</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h3><p>排除依赖会排除掉所指定的资源</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hamcrest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hamcrest-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><p>主代码有效：main文件夹内</p><p>测试代码有：test文件夹内</p><p>是否参与打包：package指令范围内</p><table><thead><tr><th align="center">scope</th><th align="center">主代码</th><th align="center">测试代码</th><th align="center">打包</th><th align="center">范例</th></tr></thead><tbody><tr><td align="center">compile(默认)</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">log4j</td></tr><tr><td align="center">test</td><td align="center">×</td><td align="center">√</td><td align="center">×</td><td align="center">junit</td></tr><tr><td align="center">provided</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">servlet-api</td></tr><tr><td align="center">runtime</td><td align="center">×</td><td align="center">×</td><td align="center">√</td><td align="center">jdbc</td></tr></tbody></table><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>插件与生命周期内的阶段绑定，在执行到对应生命周期时执行插件的功能</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-test-resources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>聚合用于一次性构建多个模块</p><p>聚合步骤</p><ul><li><p>创建空模块，打包类型定义为pom</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>定义当前模块进行构建操作时关联的其他模块名称</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>../ssm_controller<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>../ssm_service<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>../ssm_dao<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>../ssm_pojo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承步骤</p><ul><li><p>父工程中定义依赖管理</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>子工程中声明其父工程</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ssm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- pom --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../ssm/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line">&lt;/parent</span><br></pre></td></tr></table></figure></li><li><p>子工程中无需声明依赖版本</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>  自定义属性</p><p>  相当于自定义变量，方便统一维护</p>  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="内置属性"><a href="#内置属性" class="headerlink" title="内置属性"></a>内置属性</h3>  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$&#123;basedir&#125;</span><br><span class="line">$&#123;version&#125;</span><br></pre></td></tr></table></figure><h3 id="Setting属性"><a href="#Setting属性" class="headerlink" title="Setting属性"></a>Setting属性</h3><p>  使用Maven配置文件setting.xml中的标签属性</p>  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$&#123;settings.localRepository&#125;</span><br></pre></td></tr></table></figure><h3 id="Java系统属性"><a href="#Java系统属性" class="headerlink" title="Java系统属性"></a>Java系统属性</h3><p>  用来读取Java系统属性</p>  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$&#123;user.home&#125;</span><br></pre></td></tr></table></figure><p>  Java系统属性查询方式</p>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn help:system</span><br></pre></td></tr></table></figure><h3 id="环境变量属性"><a href="#环境变量属性" class="headerlink" title="环境变量属性"></a>环境变量属性</h3>  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$&#123;env.JAVA_HOME&#125;</span><br></pre></td></tr></table></figure><p>  环境变量属性查询方式</p>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn help:system</span><br></pre></td></tr></table></figure><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ul><li>SNAPSHOT,快照版本，测试阶段版本。</li><li>RELEASE，发布版本。</li></ul><h2 id="配置文件读取pom属性"><a href="#配置文件读取pom属性" class="headerlink" title="配置文件读取pom属性"></a>配置文件读取pom属性</h2><p>配置文件中的调用格式：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.url</span>=<span class="string">$&#123;jdbc.url&#125;</span></span><br></pre></td></tr></table></figure><p>pom文件写法：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.0.0.1/xxx<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h2><p>pom文件配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>pro_env<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.1.1.1:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>dev_env<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">&lt;/profiles</span><br></pre></td></tr></table></figure><p>mvn命令格式：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn 指令 –P 环境定义id</span><br><span class="line">mvn install –P pro_env</span><br></pre></td></tr></table></figure><h2 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h2><p>使用命令跳过测试</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn 指令 –D skipTests</span><br></pre></td></tr></table></figure><p>使用图形界面操作</p><img src="/archives/c35c5deb/skip-test.png" class title="跳过测试"><p>![image-20220729202521358](D:\hexo-blog\myblog\source_posts\Java 开发框架\Maven\skip-test.png)</p><p>在pom文件中配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">includes</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span>**/User*Test.java<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/User*TestCase.java<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java开发框架 </category>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热题100-栈</title>
      <link href="/archives/15f2ab9e.html"/>
      <url>/archives/15f2ab9e.html</url>
      
        <content type="html"><![CDATA[<h3 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h3><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 MinStack 类:</p><p>MinStack() 初始化堆栈对象。<br>void push(int val) 将元素val推入堆栈。<br>void pop() 删除堆栈顶部的元素。<br>int top() 获取堆栈顶部的元素。<br>int getMin() 获取堆栈中的最小元素。<br>链接：<a href="https://leetcode.cn/problems/min-stack">https://leetcode.cn/problems/min-stack</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack; </span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;(); </span><br><span class="line">        minStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        stack.push(val);</span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty() || minStack.peek() &gt;= val) &#123;</span><br><span class="line">            minStack.push(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (val == minStack.peek())&#123; </span><br><span class="line">            minStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>链接：<a href="https://leetcode.cn/problems/valid-parentheses">https://leetcode.cn/problems/valid-parentheses</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="comment">// 左括号直接入栈</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 右括号，如果栈为空或者栈中的元素无法与右括号匹配，则直接返回false</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; (stack.isEmpty() || stack.pop() != <span class="string">&#x27;(&#x27;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; (stack.isEmpty() || stack.pop() != <span class="string">&#x27;[&#x27;</span>) ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; (stack.isEmpty() || stack.pop() != <span class="string">&#x27;&#123;&#x27;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果栈中的左括号全部被匹配掉了，则为true</span></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h3><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。<br>链接：<a href="https://leetcode.cn/problems/daily-temperatures">https://leetcode.cn/problems/daily-temperatures</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[temperatures.length];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; temperatures.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;</span><br><span class="line">                res[stack.peek()] = i - stack.peek();</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty() || temperatures[i] &lt;= temperatures[stack.peek()]) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h3><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。）<br>链接：<a href="https://leetcode.cn/problems/decode-string">https://leetcode.cn/problems/decode-string</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; Character.isLetter(stack.peek())) &#123;</span><br><span class="line">                    str.insert(<span class="number">0</span>, stack.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">multiStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; Character.isDigit(stack.peek())) &#123;</span><br><span class="line">                    multiStr.insert(<span class="number">0</span>, stack.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">multi</span> <span class="operator">=</span> Integer.valueOf(multiStr.toString());</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; multi; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">char</span> a : str.toString().toCharArray()) &#123;</span><br><span class="line">                        stack.push(a);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            res.insert(<span class="number">0</span>, stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 热题100 </category>
          
          <category> 栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热题100-双指针</title>
      <link href="/archives/88ed8ca7.html"/>
      <url>/archives/88ed8ca7.html</url>
      
        <content type="html"><![CDATA[<h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。<br>链接：<a href="https://leetcode.cn/problems/3sum">https://leetcode.cn/problems/3sum</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 最外层老老实实遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 去重，你前面有一个和你相同的数，我一定用过你前面的数，所以continue</span></span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; nums[i-<span class="number">1</span>] == nums[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 第二层和第三层使用双指针，nums[j] + nums[k] = 0 - nums[i],随着j变大，k一定变小。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>, k = n-<span class="number">1</span>; j &lt; k; j++ ) &#123;</span><br><span class="line">                 <span class="comment">// 去重，你前面有一个和你相同的数，我一定用过你前面的数，所以continue</span></span><br><span class="line">                <span class="keyword">if</span> (j != i+<span class="number">1</span> &amp;&amp; nums[j] == nums[j-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 只要总和大于0，k就一直往前走</span></span><br><span class="line">                <span class="keyword">while</span> (k-<span class="number">1</span> &gt; j &amp;&amp; nums[i] + nums[j] + nums[k] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 总和不大于0了，如果等于0，说明找到了结果，如果小于0，那只能让j++了，即进入下一次循环</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[j], nums[k]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h3><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。<br>链接：<a href="https://leetcode.cn/problems/container-with-most-water">https://leetcode.cn/problems/container-with-most-water</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="comment">// 先让底边最长，然后不断移动短边，记录容积，取最大值。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            res = Math.max(</span><br><span class="line">                res, </span><br><span class="line">                (right - left) * Math.min(height[left], height[right]));            <span class="comment">// 如果移动短边，短边可能边长，容积可能会增大</span></span><br><span class="line">            <span class="comment">// 如果移动长边，就算长边变长，但是短边还是原来的短边，底边一定在变短，所以只要移动长边容积一定小。</span></span><br><span class="line">            <span class="comment">// 也有更简单的思考方式直接看容积计算公式：</span></span><br><span class="line">            <span class="comment">// (right - left) * Math.min(height[left], height[right])</span></span><br><span class="line">            <span class="comment">// (right - left) 一直在变小，想要容积变大就要Math.min(height[left], height[right]) 变大</span></span><br><span class="line">            <span class="comment">// Math.min(height[left], height[right]) 是在取短边的长度， 所以想要变大，就要让短边的长度变大 </span></span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h3><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。<br>链接：<a href="https://leetcode.cn/problems/jump-game">https://leetcode.cn/problems/jump-game</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记last是第一个能跳到i的点，那么对于i+1来说，第一个能跳到i+1的点一定&gt;=last。</span></span><br><span class="line"><span class="comment">// 如果第一个能跳到i+1的点小于last记为j且j&lt;last,则j点能跳到i+1，那么j点必能跳到i,与《last是第一个能跳到i的点》矛盾，所以，随着i点后移，last点必后移，故可用双指针计解决此问题。</span></span><br><span class="line"><span class="comment">// i点无法跳到，则i点后边的点也无法跳到。</span></span><br><span class="line"><span class="comment">// 如果j点能跳到i+1点，则j点必能跳到i点，与《i点无法跳到》矛盾。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// last表示第一个能跳到i点的点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果last跳不到当前的点，就last++,如果last=i了，表示没有点可以跳到i点，那i后面的点一定无法跳到</span></span><br><span class="line">            <span class="keyword">while</span> (last != i &amp;&amp; last + nums[last] &lt; i) &#123;</span><br><span class="line">                last++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (last == i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 热题100 </category>
          
          <category> 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热题100-数组遍历</title>
      <link href="/archives/94043fb5.html"/>
      <url>/archives/94043fb5.html</url>
      
        <content type="html"><![CDATA[<h3 id="最短无序连续子数组"><a href="#最短无序连续子数组" class="headerlink" title="最短无序连续子数组"></a>最短无序连续子数组</h3><p>给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>请你找出符合题意的 最短 子数组，并输出它的长度。<br>链接：<a href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray">https://leetcode.cn/problems/shortest-unsorted-continuous-subarray</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findUnsortedSubarray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; n &amp;&amp; nums[left + <span class="number">1</span>] &gt;= nums[left]) left++;</span><br><span class="line">        <span class="keyword">if</span> (left == n-<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[right - <span class="number">1</span>] &lt;= nums[right]) right--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; nums[i] &lt; nums[left]) left--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (right  &lt; n &amp;&amp; nums[i] &gt; nums[right]) right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a>除自身以外数组的乘积</h3><p>给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。</p><p>题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。<br>链接：<a href="https://leetcode.cn/problems/product-of-array-except-self">https://leetcode.cn/problems/product-of-array-except-self</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        left[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            left[i] = nums[i] * left[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        right[n-<span class="number">1</span>] = nums[n-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            right[i] = nums[i] * right[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        ans[<span class="number">0</span>] = right[<span class="number">1</span>];</span><br><span class="line">        ans[n-<span class="number">1</span>] = left[n-<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            ans[i] = left[i-<span class="number">1</span>] * right[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a>删除有序数组中的重复项</h3><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p><p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p><p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。<br>链接：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array">https://leetcode.cn/problems/remove-duplicates-from-sorted-array</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 想象k是新数组待放入元素的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果我前面有和我一样的数，则跳过，因为前面的数一定已经放入“新数组”中</span></span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; nums[i-<span class="number">1</span>] == nums[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// “老数组”中的数放入“新数组”中</span></span><br><span class="line">            nums[k++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h3><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。<br>链接：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 如果我要在第i天卖出，则最大收益时，我买入时是价格最低的时候</span></span><br><span class="line">        <span class="comment">// 所以统计到i天为止，最低价格，然后算我今天卖出可以赚的钱</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            min = Math.min(min, prices[i]);</span><br><span class="line">            res = Math.max(res, prices[i] - min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h3><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。<br>链接：<a href="https://leetcode.cn/problems/merge-intervals">https://leetcode.cn/problems/merge-intervals</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] parseList(List&lt;<span class="type">int</span>[]&gt; list) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        Arrays.sort(intervals,(a, b)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt; end) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, end&#125;);</span><br><span class="line">                start = intervals[i][<span class="number">0</span>];</span><br><span class="line">                end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (intervals[i][<span class="number">1</span>] &gt; end) &#123;</span><br><span class="line">                    end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, end&#125;);</span><br><span class="line">        <span class="keyword">return</span> parseList(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h3><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p><p>例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><p>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。</p><p>必须 原地 修改，只允许使用额外常数空间。<br>链接：<a href="https://leetcode.cn/problems/next-permutation">https://leetcode.cn/problems/next-permutation</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先不考虑排列，先考虑如何让一个数最小地变大，很简单，个位+1。为啥是个位，因为个位位权最小，为啥是1，因为+1之后变化最小。</span></span><br><span class="line"><span class="comment">// 想让一个排列最小地变大，一样地，尽可能地变得是后面的数，因为后面的数位权小，但是背景是排列，所以不能直接变大，而是要把一个小的数和一个大的数交换，从而达到小的数变大的效果，可是同样的，大的数也变小了，这样总体是变大了还是变小了呢？</span></span><br><span class="line"><span class="comment">// 如果我们让要交换的小的数在前，要交换的大的数在后，交换之后，总体就是变大了，</span></span><br><span class="line"><span class="comment">// 所以，我们要从后向前寻找第一个可以变大的数A，可以变大的要求是这个数A后面一定要有比他大的数，也就是数A是第一个从后向前递减的数。</span></span><br><span class="line"><span class="comment">// 而且我们想要A尽可能小地变大，所以，要从所有在A后面且比A大的数中寻找最小的数B，也就是数B是A后面的从前向后的递减序列中最后一个大于A的数，然后交换A、B，这样就实现了尽可能让低位权的数变大的要求。这样总体就变大了。</span></span><br><span class="line"><span class="comment">// 还能再变小一点吗？如果我们让已经变大的数后面的所有的数按照升序排列的话，总体还可以变小。</span></span><br><span class="line"><span class="comment">// 综上：</span></span><br><span class="line"><span class="comment">// 第一步，找到A， A是第一个从后向前递减的数</span></span><br><span class="line"><span class="comment">// 第二步，找到B， B是A后面的从前向后的递减序列中最后一个大于A的数</span></span><br><span class="line"><span class="comment">// 第三步，交换A,B</span></span><br><span class="line"><span class="comment">// 第四步，让B后面的数按照升序排列（此时，AB已经交换，B在原来A所在的位置上）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            swap(nums, start, end);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 找到A，（max-1就是A）</span></span><br><span class="line">        <span class="keyword">while</span> (max - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[max - <span class="number">1</span>] &gt;= nums[max]) max--;</span><br><span class="line">        <span class="keyword">if</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lastLarger</span> <span class="operator">=</span> max;</span><br><span class="line">            <span class="comment">// 找到B</span></span><br><span class="line">            <span class="keyword">while</span> (lastLarger + <span class="number">1</span> &lt; n &amp;&amp; nums[lastLarger + <span class="number">1</span>] &gt; nums[max-<span class="number">1</span>]) lastLarger++;  </span><br><span class="line">            <span class="comment">// 交换A、B</span></span><br><span class="line">            swap(nums, max-<span class="number">1</span>, lastLarger);</span><br><span class="line">            <span class="comment">// B后面的数升序排列，（因为原来的A后面的数是递减的，交换了A、B之后，还是递减的，所以直接逆序就是升序了）</span></span><br><span class="line">            reverse(nums, max, n-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 如果max=0,则序列是递减的，直接反转序列</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reverse(nums, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h3><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p> 链接：<a href="https://leetcode.cn/problems/majority-element/">https://leetcode.cn/problems/majority-element/</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">winner</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == winner) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    winner = nums[i];</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> winner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h3><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。<br>链接：<a href="https://leetcode.cn/problems/move-zeroes">https://leetcode.cn/problems/move-zeroes</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                nums[k++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; k &lt; nums.length; k++) &#123;</span><br><span class="line">            nums[k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 热题100 </category>
          
          <category> 数组遍历 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热题100-回溯</title>
      <link href="/archives/c6b71dcc.html"/>
      <url>/archives/c6b71dcc.html</url>
      
        <content type="html"><![CDATA[<h3 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h3><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p>链接：<a href="https://leetcode.cn/problems/generate-parentheses/">https://leetcode.cn/problems/generate-parentheses/</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> leftCnt, <span class="type">int</span> rightCnt)</span> &#123;</span><br><span class="line">        <span class="comment">// cur的长度足够时，找到了一个结果</span></span><br><span class="line">        <span class="keyword">if</span> (cur.length() == n * <span class="number">2</span>) &#123;</span><br><span class="line">            res.add(cur.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一般的回溯，这里是有个for循环表示每一层的选择，但是这个题目中每层就只有两种选择，所以可以只写for循环中的if</span></span><br><span class="line">        <span class="comment">// 如果这一层选的是左括号，则要求左括号不能太多</span></span><br><span class="line">        <span class="keyword">if</span> (leftCnt &lt; n) &#123;</span><br><span class="line">            cur.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            dfs(n, leftCnt + <span class="number">1</span>, rightCnt);</span><br><span class="line">            cur.setLength(cur.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 如果这一层选的是右括号，则要求右括号不能太多，并且右括号的数量不能超过左括号</span></span><br><span class="line">        <span class="keyword">if</span> (rightCnt &lt; n &amp;&amp; rightCnt &lt; leftCnt) &#123;</span><br><span class="line">            cur.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">            dfs(n, leftCnt, rightCnt + <span class="number">1</span>);</span><br><span class="line">            cur.setLength(cur.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        dfs(n, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h3><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><img src="/archives/c6b71dcc/phone-combination.png" class title="示意图"><p>链接：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number">https://leetcode.cn/problems/letter-combinations-of-a-phone-number</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 哈希表存储按键与字母的对应关系</span></span><br><span class="line">    HashMap&lt;Character, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[] digits, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// 找到答案</span></span><br><span class="line">        <span class="keyword">if</span> (cur.length() == digits.length) &#123;</span><br><span class="line">            res.add(cur.toString());</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 本层可做的选择 choose数组</span></span><br><span class="line">        <span class="type">char</span>[] choose = map.get(digits[index]).toCharArray();</span><br><span class="line">        <span class="comment">// 记录本层的选择是否被选择了</span></span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[choose.length];</span><br><span class="line">        <span class="comment">// 遍历本层每一个可做的选择</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; choose.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">                vis[i] = <span class="literal">true</span>;</span><br><span class="line">                cur.append(choose[i]);</span><br><span class="line">                <span class="comment">// 进入下一层</span></span><br><span class="line">                dfs(digits, index + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 返回本层</span></span><br><span class="line">                cur.setLength(cur.length() - <span class="number">1</span>);</span><br><span class="line">                vis[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        map.put(<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (digits.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> res;</span><br><span class="line">        dfs(digits.toCharArray(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。<br>链接：<a href="https://leetcode.cn/problems/permutations">https://leetcode.cn/problems/permutations</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] vis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(cur));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">                cur.add(nums[i]);</span><br><span class="line">                vis[i] = <span class="literal">true</span>;</span><br><span class="line">                dfs(nums); </span><br><span class="line">                cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">                vis[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        dfs(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。<br>链接：<a href="https://leetcode.cn/problems/subsets">https://leetcode.cn/problems/subsets</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(cur));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; nums.length; i++) &#123;</span><br><span class="line">            cur.add(nums[i]);</span><br><span class="line">            dfs(nums, i + <span class="number">1</span>);</span><br><span class="line">            cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        dfs(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合总合"><a href="#组合总合" class="headerlink" title="组合总合"></a>组合总合</h3><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p><p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。<br>链接：<a href="https://leetcode.cn/problems/combination-sum">https://leetcode.cn/problems/combination-sum</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line">    List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> index, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(cur));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == candidates.length) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target - candidates[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                cur.add(candidates[i]);</span><br><span class="line">                dfs(candidates, i, target - candidates[i]);</span><br><span class="line">                cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        dfs(candidates, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 热题100 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热题100-链表</title>
      <link href="/archives/1cfb4a7b.html"/>
      <url>/archives/1cfb4a7b.html</url>
      
        <content type="html"><![CDATA[<h3 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h3><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头<br>链接：<a href="https://leetcode.cn/problems/add-two-numbers">https://leetcode.cn/problems/add-two-numbers</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="comment">// 哑结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="comment">// 尾指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="comment">// 进位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 只要l1上有数或者l2上有数或者进位不为0就要继续算下去</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 求l1上的数data1</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">data1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                data1 = l1.val;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 求l2上的数data2</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">data2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                data2 = l2.val;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将三个数的总和累加到data1上</span></span><br><span class="line">            data1 += data2 + carry;</span><br><span class="line">            <span class="comment">// 进位</span></span><br><span class="line">            carry = data1 / <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 当前位的结果</span></span><br><span class="line">            data1 %= <span class="number">10</span>;    </span><br><span class="line">            <span class="comment">// 创建新结点  </span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(data1); </span><br><span class="line">            <span class="comment">// 新结点插到最后</span></span><br><span class="line">            tail.next = newNode;</span><br><span class="line">            tail = newNode;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>链接：<a href="https://leetcode.cn/problems/merge-two-sorted-lists/">https://leetcode.cn/problems/merge-two-sorted-lists/</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span>  dummyHead;</span><br><span class="line">        <span class="comment">// 有一个链表为空了，就可以结束循环</span></span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val &lt;= list2.val) &#123;</span><br><span class="line">                <span class="comment">// 尾插法加入新结点</span></span><br><span class="line">                tail.next = list1;</span><br><span class="line">                tail = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail.next = list2;</span><br><span class="line">                tail = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">// 最后判断哪个链表不为空</span></span><br><span class="line">        <span class="keyword">if</span> (list1 != <span class="literal">null</span>) tail.next = list1;</span><br><span class="line">        <span class="keyword">if</span> (list2 != <span class="literal">null</span>) tail.next = list2;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p>链接：<a href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。<br>链接：<a href="https://leetcode.cn/problems/linked-list-cycle">https://leetcode.cn/problems/linked-list-cycle</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h3><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>链接：<a href="https://leetcode.cn/problems/palindrome-linked-list/">https://leetcode.cn/problems/palindrome-linked-list/</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">findMid</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> findMid(head);</span><br><span class="line">        mid =  reverse(mid);</span><br><span class="line">        <span class="keyword">while</span> (mid != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val != mid.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            mid = mid.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除链表的倒数第N个结点"><a href="#删除链表的倒数第N个结点" class="headerlink" title="删除链表的倒数第N个结点"></a>删除链表的倒数第N个结点</h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p>链接：<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">end</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            end = end.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (end.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            end = end.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h3><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p>链接：<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">https://leetcode.cn/problems/intersection-of-two-linked-lists/</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">b</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">                a = a.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a = headB;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;</span><br><span class="line">                b = b.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                b = headA;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 热题100 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热题100-滑动窗口</title>
      <link href="/archives/6e5df69f.html"/>
      <url>/archives/6e5df69f.html</url>
      
        <content type="html"><![CDATA[<h3 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h3><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。<br>链接：<a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string">https://leetcode.cn/problems/find-all-anagrams-in-a-string</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : p.toCharArray()) &#123;</span><br><span class="line">            map.put(c, map.getOrDefault(c,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> map.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">satisfy</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">add</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(add)) &#123;</span><br><span class="line">                map.put(add, map.get(add) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (map.get(add) == <span class="number">0</span>) &#123;</span><br><span class="line">                    satisfy++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i - j + <span class="number">1</span> &gt; p.length()) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">delete</span> <span class="operator">=</span> s.charAt(j);</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(delete)) &#123;</span><br><span class="line">                    map.put(delete, map.get(delete) + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (map.get(delete) == <span class="number">1</span>) &#123;</span><br><span class="line">                        satisfy--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (satisfy == cnt) &#123;</span><br><span class="line">                res.add(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p>链接：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// set存储窗口中的字符</span></span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 统计每一个以 s[j] 结尾的不含重复字符的子串的长度，并不断取最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, i = <span class="number">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="comment">// 如果现在有和s[j]相同的字符，则不断增大窗口的起点</span></span><br><span class="line">            <span class="keyword">while</span> (set.contains(s.charAt(j))) &#123;</span><br><span class="line">                set.remove(s.charAt(i++));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有重复的则可以加入s[j]</span></span><br><span class="line">            set.add(s.charAt(j));</span><br><span class="line">            <span class="comment">// 取最大值</span></span><br><span class="line">            res = Math.max(res, j-i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 热题100 </category>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热题100-哈希表</title>
      <link href="/archives/9c4548f6.html"/>
      <url>/archives/9c4548f6.html</url>
      
        <content type="html"><![CDATA[<h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br>链接：<a href="https://leetcode.cn/problems/two-sum">https://leetcode.cn/problems/two-sum</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// hash表记录值和下标的对应关系</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 判断这个之前有没有数加上当前的数等于target</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="comment">// 将这个数加入hash表中</span></span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h3><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。<br>链接：<a href="https://leetcode.cn/problems/longest-consecutive-sequence/">https://leetcode.cn/problems/longest-consecutive-sequence/</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(x) &amp;&amp; !set.contains(x-<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;</span><br><span class="line">                set.remove(x);</span><br><span class="line">                <span class="keyword">while</span> (set.contains(y+<span class="number">1</span>)) &#123;</span><br><span class="line">                    y++;</span><br><span class="line">                    set.remove(y);</span><br><span class="line">                &#125;</span><br><span class="line">                res = Math.max(res, y - x + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h3><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p><p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。<br>链接：<a href="https://leetcode.cn/problems/group-anagrams">https://leetcode.cn/problems/group-anagrams</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">            Arrays.sort(chars);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(s)) &#123;</span><br><span class="line">                map.put(s, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(s).add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 热题100 </category>
          
          <category> 哈希表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热题100-动态规划</title>
      <link href="/archives/a80d0031.html"/>
      <url>/archives/a80d0031.html</url>
      
        <content type="html"><![CDATA[<h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p>链接：<a href="https://leetcode.cn/problems/convert-bst-to-greater-tree">https://leetcode.cn/problems/convert-bst-to-greater-tree</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="comment">// 因为 dp[i][j] 用到了 dp[i+1][j-1]的状态，所以i要先有大的，j要先有小的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// s[i][j] 为回文串的条件，s[i] = s[j],并且内层s[i+1][j-1]为回文串</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i+<span class="number">1</span> &gt; j-<span class="number">1</span> || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]) &#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (j-i+<span class="number">1</span> &gt; res.length()) &#123;</span><br><span class="line">                            res = s.substring(i, j + <span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h3><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p>链接：<a href="https://leetcode.cn/problems/maximum-subarray/">https://leetcode.cn/problems/maximum-subarray/</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(nums[i], dp[i-<span class="number">1</span>] + nums[i]);</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p> 链接：<a href="https://leetcode.cn/problems/climbing-stairs/">https://leetcode.cn/problems/climbing-stairs/</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] += dp[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h3><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>链接：<a href="https://leetcode.cn/problems/partition-equal-subset-sum/">https://leetcode.cn/problems/partition-equal-subset-sum/</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum /= <span class="number">2</span>;</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[sum+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> sum; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">                dp[j] |=  dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。<br>链接：<a href="https://leetcode.cn/problems/longest-increasing-subsequence">https://leetcode.cn/problems/longest-increasing-subsequence</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(dp[i], res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不同的二叉搜索数"><a href="#不同的二叉搜索数" class="headerlink" title="不同的二叉搜索数"></a>不同的二叉搜索数</h3><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p><p> 链接：<a href="https://leetcode.cn/problems/unique-binary-search-trees/">https://leetcode.cn/problems/unique-binary-search-trees/</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="comment">// dp[i] +=  dp[(j-1) -1 + 1] * dp[i - (j+1) + 1];</span></span><br><span class="line">                dp[i] +=  dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="乘积最大的子数组"><a href="#乘积最大的子数组" class="headerlink" title="乘积最大的子数组"></a>乘积最大的子数组</h3><p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p>测试用例的答案是一个 32-位 整数。</p><p>子数组 是数组的连续子序列。<br>链接：<a href="https://leetcode.cn/problems/maximum-product-subarray">https://leetcode.cn/problems/maximum-product-subarray</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preMax</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">preMin</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(nums[i], Math.max(nums[i] * preMax, nums[i] * preMin));</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(nums[i], Math.min(nums[i] * preMax, nums[i] * preMin));</span><br><span class="line">            res = Math.max(max, res);</span><br><span class="line">            preMax = max;</span><br><span class="line">            preMin = min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h3><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p><p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。<br>链接：<a href="https://leetcode.cn/problems/perfect-squares">https://leetcode.cn/problems/perfect-squares</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 1 ~ n个物品中选，每个物品i的体积:i*i, 价值::1, 要求体积为n，价值最小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, n+<span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i*i; j &lt;= n; j++) &#123;</span><br><span class="line">                dp[j] = Math.min(dp[j], dp[j - i*i] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？<br>链接：<a href="https://leetcode.cn/problems/unique-paths">https://leetcode.cn/problems/unique-paths</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i-<span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j]+= dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j-<span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] += dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h3><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。<br>链接：<a href="https://leetcode.cn/problems/minimum-path-sum">https://leetcode.cn/problems/minimum-path-sum</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = grid[i][j];</span><br><span class="line">                <span class="keyword">if</span> (j-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; i-<span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] += Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i-<span class="number">1</span> &lt; <span class="number">0</span> &amp;&amp; j-<span class="number">1</span> &gt;= <span class="number">0</span>)  &#123;</span><br><span class="line">                    dp[i][j] += dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j-<span class="number">1</span> &lt; <span class="number">0</span> &amp;&amp; i-<span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] += dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h3><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</p><p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。<br>链接：<a href="https://leetcode.cn/problems/word-break">https://leetcode.cn/problems/word-break</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (set.contains(s.substring(j,i+<span class="number">1</span>)) &amp;&amp; dp[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(nums[i] + dp[i-<span class="number">2</span>], dp[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 热题100 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
